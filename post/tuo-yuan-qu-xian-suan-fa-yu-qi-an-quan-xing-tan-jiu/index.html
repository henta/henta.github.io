<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>椭圆曲线算法与其安全性探究 | Gridea</title>
<meta name="description" content="温故而知新" />
<link rel="shortcut icon" href="https://henta.github.io/favicon.ico?v=1598437916293">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://henta.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://henta.github.io">
  <img class="avatar" src="https://henta.github.io/images/avatar.png?v=1598437916293" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              椭圆曲线算法与其安全性探究
            </h2>
            <div class="post-info">
              <span>
                2020-07-29
              </span>
              <span>
                6 min read
              </span>
              
                <a href="https://henta.github.io/tag/wyVGQd4XY/" class="post-tag">
                  # 区块链
                </a>
              
                <a href="https://henta.github.io/tag/2sOWTKJwx8/" class="post-tag">
                  # 比特币
                </a>
              
                <a href="https://henta.github.io/tag/BAUJS17jpA/" class="post-tag">
                  # 密码学
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h3 id="什么是椭圆曲线">什么是椭圆曲线？</h3>
<ul>
<li>数学中，y<sup>2</sup>=x<sup>3</sup>+ax+b这种模型，称为椭圆曲线，根据a，b的变化，椭圆曲线也会呈现不同的形状</li>
<li>例如b=1，a取值范围从2到-3<br>
<img src="https://i.loli.net/2019/05/22/5ce4be022fcdd18765.png" alt="title" loading="lazy"></li>
<li>椭圆曲线相对x轴对称</li>
<li>椭圆曲线加法：
<ul>
<li>R=P+Q https://cdn.rawgit.com/andreacorbellini/ecc/920b29a/interactive/reals-add.html</li>
</ul>
</li>
<li>椭圆曲线的乘法：
<ul>
<li>R=nP 相当于n个P相加</li>
</ul>
</li>
<li>椭圆曲线的标量积：假设n有k位二进制，可以将R=np的时间复杂度从O(2<sup>k</sup>)减少到O(logn)或者O(k)</li>
<li>椭圆曲线的逆元：每个成员都有一个相反数，比如对于a来说，有a+b=0，那么b就是a的逆元</li>
<li><strong>以上知识具体网址</strong>：https://zhuanlan.zhihu.com/p/36326221</li>
</ul>
<h3 id="离散对数与ecdsa">离散对数与ecdsa</h3>
<ul>
<li>x=log<sub>2</sub>n这种称为对数运算，上述椭圆曲线R=nP如果已知R和P求n的话，也可以算一个对数运算（绝不是除法运算，椭圆曲线的运算符定义方式和实数是不一样的）</li>
<li>有一个等式b = a<sup>k</sup> mod p，如果已知a p b，求k那么这就是一个离散对数问题，离散对数问题非常难求，最易懂的方法是穷举法，用穷举法相当于a相乘k次，当k很大时，穷举法基本不可能穷举出正确的k。<strong>还有一些其他的求离散对数的方法</strong>：https://wenku.baidu.com/view/f6b9ceb9112de2bd960590c69ec3d5bbfd0adab3.html</li>
<li>ecdsa（椭圆曲线签名算法）其实就是运用了离散对数的难求性，它将椭圆曲线mod n，所以对于R=nP来说，已知R和P，求n是一个非常难的问题，eckey中，Q=kG,k是私钥（32位的随机数），G是椭圆曲线的基点（已知），Q公钥很容易就可以求得，但是从公钥逆推k却是一个离散对数问题，基本不可能逆推出来。</li>
<li>相关知识网址：http://open.163.com/movie/2012/10/C/S/M99VIFJA6_M9EDSFLCS.html</li>
</ul>
<h3 id="ecdsa椭圆曲线签名算法">ECDSA（椭圆曲线签名算法）</h3>
<ul>
<li>不同种类的ECDSA：secp256k1和ed25519，其实用的思想是一样的，只是用的椭圆曲线不同，不同的椭圆曲线离散对数难题的难度不同，ed25519号称效率比secp256k1更好。</li>
<li>ECDSA签名算法的工作流程
<ol>
<li>取一个范围在[1, n - 1]的随机数k</li>
<li>计算点P=kG</li>
<li>计算r = X<sub>P</sub> mod n   P坐标的X轴值</li>
<li>如果 r == 0，执行第一步</li>
<li>计算s = k<sup>-1</sup> (z + r*da) mod n （da是私钥，k<sup>-1</sup> 是 k 对n的逆元 z是hash值）</li>
<li>如果s==0，执行第一步</li>
<li>二元组（r，s）就是签名值</li>
<li>通过一定格式的封装在网络上传输，不是简单的r+s</li>
</ol>
</li>
<li>ECDSA签名验证流程
<ol>
<li>计算u1 = s<sup>-1</sup> * z mod n</li>
<li>计算u2 = s<sup>-1</sup> * r mod n</li>
<li>计算P = u1<em>G + u2</em>Ha  (Ha是公钥)</li>
</ol>
<blockquote>
<p>P=u1G+u2Ha=u1G+u2daG=(u1+u2da)G<br>
将u1和u2带入，P=(s<sup>-1</sup>z+s<sup>-1</sup>rda)G=s<sup>-1</sup>(z+rda)G<br>
我们得到这个等式。<br>
然后再看看这个等式：<br>
s = k<sup>-1</sup> (z + r<em>da) mod n<br>
两边乘以(s<sup>-1</sup> * k)<br>
得到 等式 k = s<sup>-1</sup> (z + r</em>da) mod n<br>
两边再乘以G，得到<br>
kG = s<sup>-1</sup>*(z + r *da)*G mod n = P<br>
换句话说，如果(r,s)是有客户端私钥签名Z得到，则我们通过u1,u2计算的到的P值得x分量和r相同。</p>
</blockquote>
<ol start="4">
<li>如果r == X<sub>P</sub> mod n，则验证正确</li>
</ol>
</li>
</ul>
<h3 id="k的安全性问题">k的安全性问题</h3>
<blockquote>
<p>s = k<sup>-1</sup> (z + r<em>da) mod n<br>
如果k不变的话<br>
s1 = k<sup>-1</sup> (z1 + r</em>da) mod n等式1<br>
s2= k<sup>-1</sup> (z2 + r*da) mod n等式2<br>
s1 -s2 = k<sup>-1</sup> (z1 - z2) mod n<br>
z1和z2 可以自己使用哈希算法对软件进行哈希能够获取到。s1和s2能够从前面值中获取到。所以k值就轻松的获取到了<br>
k = (s1 -s2)<sup>-1</sup> * (z1 -z2) mod n<br>
而得到k之后，将k随便带入s1或者s2都很容易求出da，也就是私钥</p>
</blockquote>
<ul>
<li>如果k不是固定，但是是可以预测的，那么也是同理可以很容易求出私钥，所以k很重要，一组不好的k是有几率泄漏你的私钥的</li>
<li>关于k有过一个惨痛的教训：所以的ps3当时签名的时候，用的是固定的k，结果没过几天就被破解了</li>
</ul>
<h3 id="为什么大部分币种签名的时候得到的s和r不变呢">为什么大部分币种签名的时候得到的s和r不变呢？</h3>
<ul>
<li>按照上述流程来，签名的时候k必须是一个随机数，但是实际上，我们对同一笔输入进行签名的时候，得到的结果总是不变的，看起来就像是k固定了一样，如果k是随机的，那应该是相同输入每次签名也是不同的</li>
<li>事实上，比特币用了RFC6979协议：https://www.8btc.com/article/38766</li>
</ul>
<blockquote>
<p>简单说，比特币中k=SHA256(da + HASH(message));<br>
也就是说，k的生成和私钥有关，这样k就是独一无二的了，其实k并不是要求一定随机，而是要求独特且不可被发现。<br>
如果仅仅是针对比特币而言，这个公式已经很好了，但考虑到RFC6979面向的是密码学（不仅仅是比特币）的统一规范，要考虑更多的复杂情况（更多曲线、更多参数、更多算法等），因此，实际上的RFC6979要比上述公式复杂得多，代码实现起来也要多得多。</p>
</blockquote>
<p>算法可以复杂，代码可以很长，但原理都一样，要用私钥来保证“保密”，要用消息来保证“唯一”，再使用确定的、不可逆的方法来进行运算，最终计算出来的k值就是安全的。</p>
<p>RFC6979算法的完整实现，Java语言可参考SpongyCastle中HMacDSAKCalculator类,事实上，比特币也是直接用了该类生成k</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF">什么是椭圆曲线？</a></li>
<li><a href="#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E4%B8%8Eecdsa">离散对数与ecdsa</a></li>
<li><a href="#ecdsa%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95">ECDSA（椭圆曲线签名算法）</a></li>
<li><a href="#k%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98">k的安全性问题</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E9%83%A8%E5%88%86%E5%B8%81%E7%A7%8D%E7%AD%BE%E5%90%8D%E7%9A%84%E6%97%B6%E5%80%99%E5%BE%97%E5%88%B0%E7%9A%84s%E5%92%8Cr%E4%B8%8D%E5%8F%98%E5%91%A2">为什么大部分币种签名的时候得到的s和r不变呢？</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://henta.github.io/post/schnorr-qian-ming-yi-ji-qi-dai-lai-de-sui-ji-shu-wen-ti/">
              <h3 class="post-title">
                Schnorr签名以及其带来的随机数问题
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://henta.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
