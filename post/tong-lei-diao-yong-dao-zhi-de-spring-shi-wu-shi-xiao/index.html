<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="henta的个人博客">
<meta name="description" content="路漫漫其修远兮，吾将上下而求索">
<meta name="theme-color" content="#000">
<title>同类调用导致的spring事务失效 | Henta</title>
<link rel="shortcut icon" href="/favicon.ico?v=1604558480186">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/Atom-One-Dark.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





  <meta name="description" content="同类调用导致的spring事务失效" />
  <meta name="keywords" content="spring" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Henta</span>
            </a>  
          
        </div>
        
          <p class="subtitle">路漫漫其修远兮，吾将上下而求索</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_blank">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">henta</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">19</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">7</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">7</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://henta.github.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#%E6%A1%88%E4%BE%8B1">案例1</a></li>
<li><a href="#%E6%A1%88%E4%BE%8B2">案例2</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://henta.github.io/post/tong-lei-diao-yong-dao-zhi-de-spring-shi-wu-shi-xiao/">
      同类调用导致的spring事务失效
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2019-12-18 15:12:15">2019-12-18</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://henta.github.io/tag/_BtyPd5WF/">
        <span>spring</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>4<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>854<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <p>本人在工作过程中发现项目有一块的事务不生效，遂进行了以下的探究。本文通过两个案例深入讲解事务失效的原因以及提供一些有效的解决方法</p>
<!-- more -->
<h4 id="案例1">案例1</h4>
<pre><code class="language-java">public interface AService {
    public void a();
    public void b();
}

@Service
public class AServiceImpl implements AService{

    public void a() {
        this.b();
    }

    @Transactional(rollbackFor={Exception.class})
       public void b() {
         insert();
         update();
    }
}
</code></pre>
<p><mark>同类</mark>中一个没有@Transaction的方法调用有@Transaction的方法时，事务将会失效</p>
<ul>
<li>原因<br>
根本原因在于spring对于事务的管理方式：spring使用aop去管理事务<br>
对于上述AServiceImpl，在运行时，spring会自动生成其代理类如下：</li>
</ul>
<pre><code class="language-java">public class AServiceImplProxy implements AService{

    public void a() {
      //反射调用目标类的a方法
	AServiceImpl.a();
    }

    public void b() {
     //启动事务的代码
     begin;
     try{
       //反射调用目标类的b方法
        AServiceImpl.b();
     }catch{
	rollback;
     }
     //事务提交的代码
     commit;
    }
}

</code></pre>
<p><img src="https://i.loli.net/2019/11/22/Gz3AvxIw1eXan9i.png" alt="title" loading="lazy"><br>
在调用getBean(&quot;AServiceImpl&quot;).a()时，实际上执行的是AServiceImplProxy.a(),而AServiceImplProxy.a()调用的是源类中的a()方法，源类中a()再去调用b(),显而易见，并没有用到代理类中的AServiceImplProxy.b(),自然不会有事务管理。</p>
<h4 id="案例2">案例2</h4>
<p>a()有@Transaction b()有@Transaction或无@Transaction</p>
<pre><code class="language-java">@Service
public class AServiceImpl implements AService{
    @Transactional(rollbackFor={Exception.class})
    public void a() {
        this.b();
    }

    @Transactional(rollbackFor={Exception.class})
       public void b() {
         insert();
         update();
    }
}
</code></pre>
<ul>
<li>其实原理流程和案例1的差不多，上层类调用a()时，只会开启对于a()的事务，b的事务并没有起作用，但是因为spring的机制，会将b()自动加入到a()的事务中，所以a()方法也将b()管理了起来。</li>
<li>对于案例1，a()连事务都没有调用，自然也不会自动将b()管理到a()</li>
<li>注意点：虽然a()的事务会将b()管理起来，但是其实在b()上的注解是失效的，也就是说如果你想用不同的事务传播机制(如这种PROPAGATION_SUPPORTS)，机制将会失效,rollbackFor也只能沿用a()定义的</li>
</ul>
<h4 id="解决方案">解决方案</h4>
<ol>
<li>显式的事务编程(不推荐，丧失了aop的方便性)</li>
<li>显式的调用代理类中的b()
<ul>
<li>将暴露Proxy类设置为true@EnableAspectJAutoProxy(exposeProxy = true)</li>
<li>然后显式调用代理类的b()</li>
</ul>
</li>
</ol>
<pre><code class="language-java">@Transactional(rollbackFor={Exception.class})

public void a() {

    ((AService) AopContext.currentProxy()).b();

    //即调用AOP代理对象的b方法即可执行事务切面进行事务增强

}
</code></pre>
<p>这种做法很方便，但是不能保证以后新添加的代码不出现相同的问题<br>
3. 进行接口下沉，避免出现案例1的情况<br>
- 将一些操作数据库的通用方法放到另外的service里，这样不会出现同类调用transaction的尴尬情况<br>
- 这种做法比较优雅，也能完全避免出现事务失效的情况</p>
<h4 id="总结">总结</h4>
<ol>
<li>不仅仅是@Transaction注解，几乎所有与AOP有关的注解都存在上述的问题，工作中需要格外注意</li>
<li>现在代码大部分情况都是案例2中的情况，小部分是案例1中的情况，以后写代码的时候如果需要对注解有格外的定义，要记住案例2的情况中，注解将会失效</li>
<li>其实还是要在写代码的时候有规范意识，不要所有东西都写在一起，专业的类干专业的事</li>
<li>查看mybatis和事务日志：<br>
logging.level.com.okcoin.vault.service.dao.mapper=debug<br>
logging.level.org.springframework.jdbc.datasource.DataSourceTransactionManager=debug</li>
</ol>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      henta
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://henta.github.io/post/tong-lei-diao-yong-dao-zhi-de-spring-shi-wu-shi-xiao/" title="同类调用导致的spring事务失效">https://henta.github.io/post/tong-lei-diao-yong-dao-zhi-de-spring-shi-wu-shi-xiao/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://henta.github.io/tag/_BtyPd5WF/"># spring</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="spring定时任务" href="https://henta.github.io/post/spring-ding-shi-ren-wu/">spring定时任务</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="spring定时任务" href="https://henta.github.io/post/spring-ding-shi-ren-wu/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="闪电网络原理" href="https://henta.github.io/post/shan-dian-wang-luo/">闪电网络原理</a>
        <a class="nav-mobile-next" title="闪电网络原理" href="https://henta.github.io/post/shan-dian-wang-luo/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px;border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/yi-tai-fang/"" data-c="
          &lt;h1 id=&#34;以太坊&#34;&gt;以太坊&lt;/h1&gt;
&lt;h3 id=&#34;以太坊货币单位&#34;&gt;以太坊货币单位&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为了激励网络中的计算，需要一种一致同意的转移价值方法。为了解决这个问题，以太坊设计了一种内置的货币-以太币（Ether），也就是我们所知的ETH，有时也用古英语中的Ð表示。以太币最小的单位是Wei（伟），所有货币值都以Wei的整数倍来记录。一个以太币等于10^18 Wei。以太币还有以下单位：10^9 GWei&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;倍数&lt;/th&gt;
&lt;th&gt;单位&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10^0&lt;/td&gt;
&lt;td&gt;Wei（伟）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10^12&lt;/td&gt;
&lt;td&gt;Szabo（萨博）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10^15&lt;/td&gt;
&lt;td&gt;Finney（芬尼）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10^18&lt;/td&gt;
&lt;td&gt;Ether（以太）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在当前状况下，任何在以太币的上下文中所使用的价值标示，比如货币、余额或者支付，都应以Wei为单位来计算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分叉&#34;&gt;分叉&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基本与比特币类似，以太坊遵循一个叫做“GHOST协议(GHOST protocol.)”的数学机制。
&lt;ul&gt;
&lt;li&gt;简单的说，GHOST协议就是让我们必须选择一个在其上完成计算最多的路径。一个方法确定路径就是使用最近一个区块（叶子区块）的区块号，区块号代表着当前路径上总的区块数（不包含创世纪区块）。区块号越大，路径就会越长，就说明越多的挖矿算力被消耗在此路径上以达到叶子区块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;账户&#34;&gt;账户&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在以太坊系统中，状态是由被称为“账户”（20个字节）的对象在两个账户之间转移价值和信息的状态转换构成的。以太坊的账户包含四个部分：
&lt;ul&gt;
&lt;li&gt;nonce（随机数）：用于确定每笔交易只能被处理一次的计数器，这个值等于由此账户地址发出的交易数量，或者由这个账户所创建的合约数量（当这个账户有关联代码时）。&lt;/li&gt;
&lt;li&gt;balance（账户余额）：账户目前的以太币余额&lt;/li&gt;
&lt;li&gt;storageRoot：理论上是指Merkle Patricia树的根节点256位的Hash值。&lt;/li&gt;
&lt;li&gt;codeHash：此账户EVM代码的hash值。对于外部拥有账户，codeHash域是一个空字符串，对于合约账户，就是代码的Hash作为codeHash保存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以太坊分为外部账户和合约账户。外部所有的账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取和写入，和发送其它消息或者创建合约。
&lt;ul&gt;
&lt;li&gt;外部账户（EOA）：拥有一个私钥，可以拥有币，可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部拥有账户或合约账户，被私钥控制且没有任何代码与之关联了。和比特币一样。&lt;/li&gt;
&lt;li&gt;合约账户：被他们的合约代码控制且有代码与之关联，每个合约部署之后都会有一个合约账户，只能通过EOA账户操作，EOA账户可以通过编写特定的程序代码来掌控合约账户，合约账户只有在EOA账户执行一个指令才会去发生操作，自己本身不会发生操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;交易&#34;&gt;交易&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;交易数据结构：
&lt;ul&gt;
&lt;li&gt;nonce：与发送该交易的账户的nonce值一致。&lt;/li&gt;
&lt;li&gt;gasPrice：表示每gas的单价为多少wei。&lt;/li&gt;
&lt;li&gt;gasLimit：执行该条交易最大被允许使用的gas数目。&lt;/li&gt;
&lt;li&gt;to：160位的接受者地址。当交易位创建合约时，该值位空。&lt;/li&gt;
&lt;li&gt;value：表示发送者发送的wei的数目。该值为向接受者转移的wei的数目，或者是创建合约时作为合约账户的初始wei数目。&lt;/li&gt;
&lt;li&gt;v,r,s：交易的签名信息，用以决定交易的发送者。&lt;/li&gt;
&lt;li&gt;init：如果是创建合约的交易,则init表示一段不限长度的EVM-Code用以合约账户初始化的过程。&lt;/li&gt;
&lt;li&gt;data: 调用合约的交易，会包含一段不限长度的输入信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;区块&#34;&gt;区块&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;区块头数据结构：
&lt;ul&gt;
&lt;li&gt;parentHash: 父节点的hash值。&lt;/li&gt;
&lt;li&gt;ommersHash: uncle节点的hash值，这块是跟GHOST相关的。&lt;/li&gt;
&lt;li&gt;beneficiary: 矿工address。&lt;/li&gt;
&lt;li&gt;stateRoot: 当所有交易都执行完毕后的世界状态树的根节点。&lt;/li&gt;
&lt;li&gt;transactionsRoot: 交易列表的根节点。&lt;/li&gt;
&lt;li&gt;receiptsRoot: 收据的根节点。&lt;/li&gt;
&lt;li&gt;logsBloom:日志过滤器。&lt;/li&gt;
&lt;li&gt;difficulty:区块难度，根据上一个区块的难度以及时间戳算出来的值。&lt;/li&gt;
&lt;li&gt;number:区块号。&lt;/li&gt;
&lt;li&gt;gasLimit: 区块的gas数量限制，即区块中交易使用掉的gas值不应该超过该值。&lt;/li&gt;
&lt;li&gt;gasUsed: 区块使用掉的gas数量。&lt;/li&gt;
&lt;li&gt;timestamp: 时间戳。&lt;/li&gt;
&lt;li&gt;extraData: 额外的数据，合法的交易对长度有限制。&lt;/li&gt;
&lt;li&gt;mixHash: 与nonce一起用作工作量证明。&lt;/li&gt;
&lt;li&gt;nonce: 与mixHash一起用作工作量证明。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">以太坊</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/diffie-hellman-mi-yao-jiao-huan-he-pbe/"" data-c="
          &lt;h4 id=&#34;diffie-hellman&#34;&gt;Diffie-Hellman&lt;/h4&gt;
&lt;p&gt;事实上，Diffie-Hellman并不是秘钥交换，它的实质是通信双方通过公开的东西共同计算出了私钥&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/10/10/jlXs63C7JPpqMau.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从上图的流程中可以看出A 和 B是双方私有的，但是公开出来的数实际上是一个对数难题，黑客无法通过计算反推出A和B，自然也就无法推出G^(A*B) mod P这个共享秘钥了&lt;/li&gt;
&lt;li&gt;其实用椭圆曲线算法也可以实现Diffie-Hellman秘钥交换，总体流程是差不多的&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/10/10/O3osk79PWV5XCcK.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;pbe基于口令的密码&#34;&gt;PBE（基于口令的密码）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/10/10/ZJhKk7oqeUf8gvz.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
以后我们只需要保存KEK和盐，然后通过一个口令就可以生成原始的秘钥对消息进行加密了，机器上并不会保存原始的秘钥，所以哪怕机器被盗，黑客也无法知道秘钥&lt;/p&gt;
">Diffie-Hellman秘钥交换和PBE</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/shu-zi-qian-ming-he-zheng-shu/"" data-c="
          &lt;h4 id=&#34;数字签名&#34;&gt;数字签名&lt;/h4&gt;
&lt;p&gt;数字签名相当于盖章、签字，既可以识别篡改和伪装，还可以防止否认&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想一想消息认证码为什么会有无法识别否认的缺点，根源上在于接受者和发送者共用了同一个秘钥，都可以生成相同的MAC值，因此第三方无法证明消息是谁生成的&lt;/li&gt;
&lt;li&gt;既然知道根本原因了，那么我们只需要设计出一种方法：发送方用自己的秘钥进行消息认证加密，接受方用自己的秘钥可以对消息进行解密验证。其实这种模式很熟悉，就是公私钥技术&lt;/li&gt;
&lt;li&gt;数字签名就是利用了公私钥技术的一种模式&lt;br&gt;
下面是一个表格来辨析数字签名和公钥密码的不同（其实就是将公钥密码技术反过来用）&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/10/09/GFD2NICsUEgmM4r.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数字签名的一般流程&#34;&gt;数字签名的一般流程&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/10/09/rvPEs1dJY5leN8L.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;我们一般不对消息直接进行签名，而是对消息hash之后的值进行加密，因为hash之后的值是定长，这样签名的长度也可以固定，可以是一个比原始消息小得多的值&lt;/li&gt;
&lt;li&gt;数字签名只是为了代表只有持有秘钥的人才可以生成信息，并且所有的人都可以认证是他生成的信息&lt;/li&gt;
&lt;li&gt;消息认证码和数字签名都是认证符号的一种&lt;/li&gt;
&lt;li&gt;数字签名本身并不保证消息的机密性，因为数字签名的目的根本不是这个，要保证消息的机密性还得利用其它的密码学方法对消息进行加密&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;数字签名的具体实现可以用RSA或者椭圆曲线算法（ECDSA）等&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;攻击&#34;&gt;攻击&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;中间人攻击：可以看出数字签名需要公私钥，假设alice向bob发送消息，应该先发送公钥，这时候黑客截断了消息，将自己的公钥发送给了bob，bob以为这就是alice的公钥，放心的开始验证消息了，其实后面的消息都是黑客发的了，这样bob就上当了。要避免这种攻击，证书就派上用场了&lt;/li&gt;
&lt;li&gt;比如利用RSA进行消息加密，公式是：密文=消息&lt;sup&gt;EmodN,而签名是这样的签名=消息&lt;/sup&gt;DmodN,如果黑客将alice发送的加密的消息截取到了，并通过社工的方式欺骗bob对这一段密文进行一下数字签名，那么会发生以下的情况：&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/10/09/9EAkmDZNnBb3CuL.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样黑客就相当于把消息解密了。所以我们需要注意不要随便答应别人对未知数据进行数字签名&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;证书&#34;&gt;证书&lt;/h4&gt;
&lt;p&gt;数字签名虽然解决了很多问题，但是公钥的归属性是个大问题，归根结底，我们需要一个信任种子，这就有了证书机构，证书机构是具有权威性的，他可以证明哪个公钥是属于你的，而接收方通过这个证书也能判定这个公钥到底是谁的&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/10/10/O9AdaejfI2Dk4oq.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">数字签名和证书</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/dui-cheng-jia-mi/"" data-c="
          &lt;h3 id=&#34;xor异或&#34;&gt;XOR（异或）&lt;/h3&gt;
&lt;p&gt;异或运算是二进制的运算，运算规则如下&lt;br&gt;
- 0 XOR 0=0&lt;br&gt;
- 0 XOR 1=1&lt;br&gt;
- 1 XOR 0=1&lt;br&gt;
- 1 XOR 1=0&lt;br&gt;
其实就是同0异1&lt;br&gt;
异或运算的规律:&lt;br&gt;
- A XOR B = C 可以反推出 B XOR C=A&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这其实就是一次性密码本加密解密的过程 A是明文，B是加密密码，C是加密后的密文，解密的时候只需要知道加密密码就能解密出明文了，对于异或来说，如果知道C但是不知道B，那么A有无数种可能，所以没办法通过密文直接推出明文&lt;/li&gt;
&lt;li&gt;一次性密码本理论上是无法破译的，但是一次性密码本的应用并不广泛，原因是秘钥的配送问题，你无法将B安全的传到接收方手中，而且明文越长，B就会越长，局限性太大&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;des&#34;&gt;DES&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Feistel网络&lt;br&gt;
在Feistel网络中，解密的各个步骤成为轮（round），加密过程就是进行若干次轮的循环，DES是16轮的Feistel网络&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/09/27/pmekLhrQbyuNZM6.png&#34; alt=&#34;Feistel网络&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一轮的子秘钥都不同&lt;/li&gt;
&lt;li&gt;通过XOR的性质可以知道，在1轮中，我们只需要将右侧和子秘钥通过轮函数组合，再和加密后的左侧做XOR操作就可以得出未加密的左侧。因为右侧就是明文，轮函数不会变，所以我们只需要知道子秘钥就能解密了。&lt;/li&gt;
&lt;li&gt;总共16轮，每轮过后左右侧都会调换，保证明文都被加密，解密过程也是一样经过16轮就行了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DES已经可以在现实的时间内暴力破解，因此有了三重DES（TDES，3DES）&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/09/27/r5f67IyiNY34hzW.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TDES其实就是进行三次DES，每次用的DES秘钥不一样&lt;/li&gt;
&lt;li&gt;之所以设计成加密解密加密的顺序是为了兼容DES，DES解密只需要3次秘钥相同其实就相当于进行了一次解密&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aes&#34;&gt;AES&lt;/h3&gt;
&lt;p&gt;AES用了Rijndeal算法，这个算法没有使用Feistel网络模型而是改用了SPN结构。&lt;/p&gt;
&lt;h3 id=&#34;分组模式&#34;&gt;分组模式&lt;/h3&gt;
&lt;p&gt;DES和AES都是分组加密，即每次只能加密一定长度的明文，想要加密更长长明文必须以组为单位进行反复。&lt;br&gt;
DES和TDES的分组长度是64比特，而AES的分组长度是128比特&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ECB模式（电子密码本模式）&lt;br&gt;
将明文直接分割成若干个组然后分别进行加密
&lt;ul&gt;
&lt;li&gt;&lt;mark&gt;这种模式有很大的弱点，目前已经不推荐使用这种模式&lt;/mark&gt;
&lt;ol&gt;
&lt;li&gt;如果明文中有重复，这种模式加密出来的结果也会有重复，黑客可以通过寻找规律，大大降低破解难度&lt;/li&gt;
&lt;li&gt;因为是顺序分组，如果明文中的分组刚好是A组：转账方 B组：金额 C组：收账方，黑客并不需要通过破解密文而只需要打乱密文顺序将A和C调换位置就可以达到转账调用的目的，这非常危险（当然这一点可以通过使用消息认证码技术加以克服，但是其他模式原生就不会被这样攻击）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CBC模式（密文分组链接模式）&lt;br&gt;
将明文分组与前一个密文分组进行XOR运算，然后再进行加密&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/09/29/uja7rIUBoJmLMVT.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;
&lt;ul&gt;
&lt;li&gt;相比于ECB模式，CBC先进行了一次XOR运算，这样一来哪怕明文中有两个组是重复的，密文也不会重复&lt;/li&gt;
&lt;li&gt;解密过程中，如果硬盘上有一个密文分组损坏了，那么也只会影响本组和下一个组的的解密（因为解密只需要上一个组的密文）：&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/09/29/FdsaXznPoV1Mp3E.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;SSL/TSL 使用了CBC模式，TDES和AES也都有CBC模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">对称加密</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/san-lie-han-shu/"" data-c="
          &lt;h4 id=&#34;sha-2&#34;&gt;SHA-2&lt;/h4&gt;
&lt;p&gt;SHA-2包含6个版本，但是实际上这6个版本都是由SHA-256和SHA-512这两个版本衍生出来的，其中224和256因为采用了32*8的内部状态，更适合32位cpu&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/10/10/BErXZ2mcPWdN7oF.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;ripemd-160&#34;&gt;RIPEMD-160&lt;/h4&gt;
&lt;p&gt;RPIEMD-160能够产生160比特的散列值，RIPEMD还包括128，256，320等的其他版本，RIPEMD的强抗碰撞性已经在2004年被攻破了，但是RPIEMD-160的还没有被攻破，比特币用的就是RPIEMD-160&lt;/p&gt;
&lt;h4 id=&#34;sha-3&#34;&gt;SHA-3&lt;/h4&gt;
&lt;p&gt;SHA-3采用了Keccak算法，有224、256、384、512这4种版本&lt;/p&gt;
">散列函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/base-xi-lie/"" data-c="
          &lt;h3 id=&#34;base64&#34;&gt;BASE64&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;BASE64就是一种基于64个可打印字符来表示二进制数据的方法
&lt;ul&gt;
&lt;li&gt;BASE64使用了26个小写字母，26个大写字母、10个数字以及两个符号（+和/），用于在电子邮件这样的基于文本的媒介中传输二进制数据。&lt;/li&gt;
&lt;li&gt;BASE64通常用于编码邮件中的附件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BASE64字符集&lt;img src=&#34;https://i.loli.net/2019/03/20/5c91b8fd5104c.png&#34; alt=&#34;20190320115227-image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;BASE64的步骤
&lt;ol&gt;
&lt;li&gt;将每个字符转成ASCII编码（10进制）&lt;/li&gt;
&lt;li&gt;将10进制编码转成2进制编码&lt;/li&gt;
&lt;li&gt;将2进制编码按照6位一组进行平分&lt;/li&gt;
&lt;li&gt;将6位一组的2进制数高位补零，然后转成10进制数&lt;/li&gt;
&lt;li&gt;将10进制数作为索引，从BASE64编码中查找字符&lt;/li&gt;
&lt;li&gt;转换后的结果是每3个字符的文本将编码为4个字符长度（3*8=4*6）
&lt;ol&gt;
&lt;li&gt;若文本为3个字符，则正好编码为4个字符长度&lt;/li&gt;
&lt;li&gt;若文本为2个字符，则编码为3个字符，由于不足4个字符，则在尾部用一个”=“来补齐&lt;/li&gt;
&lt;li&gt;若文本为1个字符，则编码为2个字符，由于不足4个字符，则在尾部用两个”=“来补齐&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;例子：&lt;img src=&#34;https://i.loli.net/2019/03/20/5c91b941ed3bf.png&#34; alt=&#34;20190320115336-image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;base58&#34;&gt;BASE58&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;BASE58是一种基于文本的二进制编码格式，用在比特币和其他的加密货币中。这种编码格式不仅实现了数据压缩，保持了易读性，还具有错误诊断的功能。&lt;/li&gt;
&lt;li&gt;BASE58是BASE64编码格式的子集，它舍弃了数字0和大写字母O，大写字母I和小写字母i，以及+和/&lt;/li&gt;
&lt;li&gt;编码表&lt;img src=&#34;https://i.loli.net/2019/03/20/5c91f5c47b117.png&#34; alt=&#34;20190320161147-image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;base58check&#34;&gt;BASE58Check&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Base58Check是一种常用在比特币中的Base58编码格式，增加了错误校验来检查数据在转录中出现的错误
&lt;ul&gt;
&lt;li&gt;校验码长4个字节，添加到需要编码的数据之后。&lt;/li&gt;
&lt;li&gt;校验码是从需要编码的数据的哈希值中得到的，所以可以用来检测并避免转录和输入中产生的错误&lt;/li&gt;
&lt;li&gt;使用Base58Check编码格式时，编码软件会计算原始数据的校验码并和结果数据中自带的校验码进行比对，二者不匹配则表明有错误产生，那么这个Base58Check格式的数据就是无效的。例如，一个错误比特币地址就不会被钱包认为是有效的地址，否则这种错误会造成资金的丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为了使用Base58Check编码格式对数据（数字）进行编码，首先我们要对数据添加一个称作”版本字节“的前缀，这个前缀用来明确需要编码的数据的类型。
&lt;ul&gt;
&lt;li&gt;例如，比特币地址的前缀是0（十六进制是Ox00），而对私钥编码时前缀是128（十六进制时Ox80）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;比特币地址生成例子：&lt;img src=&#34;https://i.loli.net/2019/03/20/5c91f7632a6ba.png&#34; alt=&#34;20190320161842-屏幕快照 2019-03-20 下午3.28.01.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
真正的base58check步骤是第4步及其之后&lt;/li&gt;
&lt;/ul&gt;
">Base系列</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/tuo-yuan-qu-xian-suan-fa-yu-qi-an-quan-xing-tan-jiu/"" data-c="
          &lt;h3 id=&#34;什么是椭圆曲线&#34;&gt;什么是椭圆曲线？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数学中，y&lt;sup&gt;2&lt;/sup&gt;=x&lt;sup&gt;3&lt;/sup&gt;+ax+b这种模型，称为椭圆曲线，根据a，b的变化，椭圆曲线也会呈现不同的形状&lt;/li&gt;
&lt;li&gt;例如b=1，a取值范围从2到-3&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/05/22/5ce4be022fcdd18765.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;椭圆曲线相对x轴对称&lt;/li&gt;
&lt;li&gt;椭圆曲线加法：
&lt;ul&gt;
&lt;li&gt;R=P+Q https://cdn.rawgit.com/andreacorbellini/ecc/920b29a/interactive/reals-add.html&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;椭圆曲线的乘法：
&lt;ul&gt;
&lt;li&gt;R=nP 相当于n个P相加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;椭圆曲线的标量积：假设n有k位二进制，可以将R=np的时间复杂度从O(2&lt;sup&gt;k&lt;/sup&gt;)减少到O(logn)或者O(k)&lt;/li&gt;
&lt;li&gt;椭圆曲线的逆元：每个成员都有一个相反数，比如对于a来说，有a+b=0，那么b就是a的逆元&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;以上知识具体网址&lt;/strong&gt;：https://zhuanlan.zhihu.com/p/36326221&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;离散对数与ecdsa&#34;&gt;离散对数与ecdsa&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;x=log&lt;sub&gt;2&lt;/sub&gt;n这种称为对数运算，上述椭圆曲线R=nP如果已知R和P求n的话，也可以算一个对数运算（绝不是除法运算，椭圆曲线的运算符定义方式和实数是不一样的）&lt;/li&gt;
&lt;li&gt;有一个等式b = a&lt;sup&gt;k&lt;/sup&gt; mod p，如果已知a p b，求k那么这就是一个离散对数问题，离散对数问题非常难求，最易懂的方法是穷举法，用穷举法相当于a相乘k次，当k很大时，穷举法基本不可能穷举出正确的k。&lt;strong&gt;还有一些其他的求离散对数的方法&lt;/strong&gt;：https://wenku.baidu.com/view/f6b9ceb9112de2bd960590c69ec3d5bbfd0adab3.html&lt;/li&gt;
&lt;li&gt;ecdsa（椭圆曲线签名算法）其实就是运用了离散对数的难求性，它将椭圆曲线mod n，所以对于R=nP来说，已知R和P，求n是一个非常难的问题，eckey中，Q=kG,k是私钥（32位的随机数），G是椭圆曲线的基点（已知），Q公钥很容易就可以求得，但是从公钥逆推k却是一个离散对数问题，基本不可能逆推出来。&lt;/li&gt;
&lt;li&gt;相关知识网址：http://open.163.com/movie/2012/10/C/S/M99VIFJA6_M9EDSFLCS.html&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ecdsa椭圆曲线签名算法&#34;&gt;ECDSA（椭圆曲线签名算法）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不同种类的ECDSA：secp256k1和ed25519，其实用的思想是一样的，只是用的椭圆曲线不同，不同的椭圆曲线离散对数难题的难度不同，ed25519号称效率比secp256k1更好。&lt;/li&gt;
&lt;li&gt;ECDSA签名算法的工作流程
&lt;ol&gt;
&lt;li&gt;取一个范围在[1, n - 1]的随机数k&lt;/li&gt;
&lt;li&gt;计算点P=kG&lt;/li&gt;
&lt;li&gt;计算r = X&lt;sub&gt;P&lt;/sub&gt; mod n   P坐标的X轴值&lt;/li&gt;
&lt;li&gt;如果 r == 0，执行第一步&lt;/li&gt;
&lt;li&gt;计算s = k&lt;sup&gt;-1&lt;/sup&gt; (z + r*da) mod n （da是私钥，k&lt;sup&gt;-1&lt;/sup&gt; 是 k 对n的逆元 z是hash值）&lt;/li&gt;
&lt;li&gt;如果s==0，执行第一步&lt;/li&gt;
&lt;li&gt;二元组（r，s）就是签名值&lt;/li&gt;
&lt;li&gt;通过一定格式的封装在网络上传输，不是简单的r+s&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;ECDSA签名验证流程
&lt;ol&gt;
&lt;li&gt;计算u1 = s&lt;sup&gt;-1&lt;/sup&gt; * z mod n&lt;/li&gt;
&lt;li&gt;计算u2 = s&lt;sup&gt;-1&lt;/sup&gt; * r mod n&lt;/li&gt;
&lt;li&gt;计算P = u1&lt;em&gt;G + u2&lt;/em&gt;Ha  (Ha是公钥)&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;P=u1G+u2Ha=u1G+u2daG=(u1+u2da)G&lt;br&gt;
将u1和u2带入，P=(s&lt;sup&gt;-1&lt;/sup&gt;z+s&lt;sup&gt;-1&lt;/sup&gt;rda)G=s&lt;sup&gt;-1&lt;/sup&gt;(z+rda)G&lt;br&gt;
我们得到这个等式。&lt;br&gt;
然后再看看这个等式：&lt;br&gt;
s = k&lt;sup&gt;-1&lt;/sup&gt; (z + r&lt;em&gt;da) mod n&lt;br&gt;
两边乘以(s&lt;sup&gt;-1&lt;/sup&gt; * k)&lt;br&gt;
得到 等式 k = s&lt;sup&gt;-1&lt;/sup&gt; (z + r&lt;/em&gt;da) mod n&lt;br&gt;
两边再乘以G，得到&lt;br&gt;
kG = s&lt;sup&gt;-1&lt;/sup&gt;*(z + r *da)*G mod n = P&lt;br&gt;
换句话说，如果(r,s)是有客户端私钥签名Z得到，则我们通过u1,u2计算的到的P值得x分量和r相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;如果r == X&lt;sub&gt;P&lt;/sub&gt; mod n，则验证正确&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;k的安全性问题&#34;&gt;k的安全性问题&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;s = k&lt;sup&gt;-1&lt;/sup&gt; (z + r&lt;em&gt;da) mod n&lt;br&gt;
如果k不变的话&lt;br&gt;
s1 = k&lt;sup&gt;-1&lt;/sup&gt; (z1 + r&lt;/em&gt;da) mod n等式1&lt;br&gt;
s2= k&lt;sup&gt;-1&lt;/sup&gt; (z2 + r*da) mod n等式2&lt;br&gt;
s1 -s2 = k&lt;sup&gt;-1&lt;/sup&gt; (z1 - z2) mod n&lt;br&gt;
z1和z2 可以自己使用哈希算法对软件进行哈希能够获取到。s1和s2能够从前面值中获取到。所以k值就轻松的获取到了&lt;br&gt;
k = (s1 -s2)&lt;sup&gt;-1&lt;/sup&gt; * (z1 -z2) mod n&lt;br&gt;
而得到k之后，将k随便带入s1或者s2都很容易求出da，也就是私钥&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果k不是固定，但是是可以预测的，那么也是同理可以很容易求出私钥，所以k很重要，一组不好的k是有几率泄漏你的私钥的&lt;/li&gt;
&lt;li&gt;关于k有过一个惨痛的教训：所以的ps3当时签名的时候，用的是固定的k，结果没过几天就被破解了&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么大部分币种签名的时候得到的s和r不变呢&#34;&gt;为什么大部分币种签名的时候得到的s和r不变呢？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;按照上述流程来，签名的时候k必须是一个随机数，但是实际上，我们对同一笔输入进行签名的时候，得到的结果总是不变的，看起来就像是k固定了一样，如果k是随机的，那应该是相同输入每次签名也是不同的&lt;/li&gt;
&lt;li&gt;事实上，比特币用了RFC6979协议：https://www.8btc.com/article/38766&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;简单说，比特币中k=SHA256(da + HASH(message));&lt;br&gt;
也就是说，k的生成和私钥有关，这样k就是独一无二的了，其实k并不是要求一定随机，而是要求独特且不可被发现。&lt;br&gt;
如果仅仅是针对比特币而言，这个公式已经很好了，但考虑到RFC6979面向的是密码学（不仅仅是比特币）的统一规范，要考虑更多的复杂情况（更多曲线、更多参数、更多算法等），因此，实际上的RFC6979要比上述公式复杂得多，代码实现起来也要多得多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;算法可以复杂，代码可以很长，但原理都一样，要用私钥来保证“保密”，要用消息来保证“唯一”，再使用确定的、不可逆的方法来进行运算，最终计算出来的k值就是安全的。&lt;/p&gt;
&lt;p&gt;RFC6979算法的完整实现，Java语言可参考SpongyCastle中HMacDSAKCalculator类,事实上，比特币也是直接用了该类生成k&lt;/p&gt;
">椭圆曲线算法与其安全性探究</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/schnorr-qian-ming-yi-ji-qi-dai-lai-de-sui-ji-shu-wen-ti/"" data-c="
          &lt;h3 id=&#34;schnorr&#34;&gt;Schnorr&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;签名流程&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Q = kG&lt;br&gt;
r = hash(Q, Ha, msg) mod n&lt;br&gt;
s = k - r * da mod n&lt;br&gt;
其中da是私钥,Ha是公钥&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;验证流程&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;s * G=Ha * hash(Q, Ha, msg)+Q&lt;br&gt;
如果相等的话，验证成功&lt;br&gt;
其中Ha是公钥&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;schnorr的优缺点&#34;&gt;Schnorr的优缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;多笔签名一起验证，提高效率
&lt;ul&gt;
&lt;li&gt;对于ECDSA来说，同时验证多笔签名只能一笔一笔的验证，但是对于Schnorr来说，可以多笔签名一起验证&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;(s1+s2+…+s1000)×G=(Q1+…+Q1000)+(hash(Q1,Ha1,msg1)×Ha1+ hash(Q2,Ha2,msg2)×Ha2+…+hash(Q1000,Ha1000,msg1000)×Ha1000)&lt;br&gt;
椭圆曲线其实是一个阿尔贝群，虽然它的运算符号特殊，但是也符合交换律，结合律等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一起验证签名可以降低计算难度&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;对比一下一起签名和一笔一笔签名有什么不同&lt;br&gt;
一起签名的情况下，对于1000笔签名来说，其实进行了很多加法+1001次乘法&lt;br&gt;
如果是分开签名则要进行2000次乘法&lt;br&gt;
椭圆曲线的乘法比加法慢的多的多，所以将乘法转为加法可以大大提升效率&lt;br&gt;
再观察一下ECDSA，1000笔签名需要1000次倒置和2000次点乘运算，理论上整理效率不如Schnorr算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;个人观点：这个优点我觉得不是很重要。。。。按照btc10分钟一个块，ecdsa验证顶多慢几s,没啥大影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;秘钥聚合&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;https://www.8btc.com/article/359642&lt;br&gt;
使用schnorr签名，我们可以使用一对私钥 (pk1,pk2)，并以此生成一个共享公钥P=P1+P2=pk1×G+pk2×G，共享公钥可以用来解共享签名（r1+r2,s1+s2）&lt;br&gt;
schnorr秘钥聚合也经历了很多版本，最初的秘钥聚合有流氓攻击风险：https://bitcointechtalk.com/scaling-bitcoin-schnorr-signatures-abe3b5c275d1，现在基本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;p&gt;都是用Mu-sig这个实现&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少空间占用
&lt;ul&gt;
&lt;li&gt;比特币的做法：我们希望能用两个或者多个私钥共同控制比特币，目前的做法是n-of-m多重签名脚本，多重签名的个数越多，链上需要包含的签名size就越大（但是有隔离见证）&lt;/li&gt;
&lt;li&gt;使用schnorr签名，无论多少个私钥控制签名，只需要签一个名即可，可以节省空间&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这虽然是个有点，但是这并不是很重要。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;增强隐私性
&lt;ul&gt;
&lt;li&gt;比特币多签P2SH几乎是无隐私的，P2SH地址以3开头，这使得区块链观察者可以识别网络中所有的P2SH交易，并且确定哪些对象参与了多签交易&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/05/24/5ce75c0d425c728270.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;Schnorr的秘钥聚合却可以保证用户的隐私性，因为它会将几个公钥聚合成一把，这样观察者就不知道到底有几个人参与签名，到底是谁参与签名&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/05/24/5ce75d5c5c15155129.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;无法使用确定性k进行签名
&lt;ul&gt;
&lt;li&gt;比特币其实用的是一个确定性k，这个k也非常有安全保障，但是Schnorr却不能使用这种模式，如果使用可确定性k，哪怕它是和你的私钥挂钩，黑客也能通过签名获取你的私钥&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;假设有人入侵了我们的电脑并完全控制了两个私钥中的一个（假设叫da），因为是多签，攻击者拿到一个私钥暂时也无法发送交易&lt;br&gt;
但是当我们发送交易的时候需要da和db两把私钥，我们尝试像往常一样进行交易，我们准备一个未签名的交易和Q1 = k1G的值将他转移到硬件钱包进行离线签名，返回了（r1，s1）但是因为某些原因，我们发送交易的在线钱包并没有将交易发出去，这时候我们可能需要重新签名再尝试发送交易，这次我们使用了Q2=k2G发送到硬件钱包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;随机数&#34;&gt;随机数&lt;/h3&gt;
&lt;p&gt;Schnorr的k必须用随机数生成，那么产生随机数就成了一个难题&lt;br&gt;
linux上的随机数用的是/dev/random或者/dev/urandom&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;熵：可以理解为系统的操作，系统的不同操作会产生不同的熵，如键盘的输入、鼠标的移动、内存的使用、文件的使用量、进程数量等等。这些熵可以看做是哲学意义上的随机，这些熵正是linux随机数的源头&lt;br&gt;
java默认使用/dev/random&lt;/li&gt;
&lt;li&gt;/dev/random 在系统熵不够的情况下会阻塞，所以如果程序大量调用默认随机数，就会产生阻塞，一次阻塞个两三分钟还是很正常的&lt;/li&gt;
&lt;li&gt;/dev/urandom 哪怕熵不够也不会阻塞&lt;/li&gt;
&lt;li&gt;实际上/dev/random和/dev/urandom都是经过伪随机数生成器（CSPRNG）所得:http://www.linuxeden.com/a/48277&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;别问，问就是用 /dev/urandom&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/05/27/5ceb67e212b6e34501.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;从图中看来，其实urandom就是直接拿熵池中的数据当seed生成大量随机数，而random会判断熵池够不够数量，够数量才会用CSPRNG生成，random会保证每次用的熵不同&lt;br&gt;
但其实哪怕是urandom，他的seed也不会是固定的，他会用新熵去“洗种”，所以urandom的安全性并不差&lt;/p&gt;
&lt;h3 id=&#34;为什么大部分币种生成私钥的时候没有随机数问题&#34;&gt;为什么大部分币种生成私钥的时候没有随机数问题？&lt;/h3&gt;
&lt;p&gt;其实他们也是从/dev/random拿的，不过他们只拿一次作为java程序中伪随机数生成器（类似CSPRNG）的seed，通过这个随机的seed，可以无限生成伪随机数，同一个seed产生的随机数是一样的&lt;/p&gt;
">Schnorr签名以及其带来的随机数问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/shan-dian-wang-luo-chong-dong-gong-ji/"" data-c="
          &lt;h2 id=&#34;htlc&#34;&gt;HTLC&lt;/h2&gt;
&lt;p&gt;Alice的目标是要将1btc转给Dave，但是自己并没有与之相连的通道，这时候就要找到与Dave的通道连接的节点，间接将钱支付给Dave&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dave创建一个随机数R，并且Hash（R），我们将其称为H，然后将H传输给Alice&lt;/li&gt;
&lt;li&gt;Alice发布一个悬赏：也就是HTLC，悬赏的大致意思是:谁能将R给我，我就给谁1.02个btc&lt;/li&gt;
&lt;li&gt;Bob接下了Alice的悬赏，但是Bob并没有R，所以Bob也发布了一个悬赏：谁能将R给我，我就给谁1.01个btc&lt;/li&gt;
&lt;li&gt;Carol接下了Bob的悬赏，但是Carol也没有R，所以Carol发布悬赏：谁能将R给我，我就给谁1.00个btc，因为通道相连，Dave直接接下这个悬赏，并且将R给了Carol&lt;/li&gt;
&lt;li&gt;Carol接收到了R&lt;/li&gt;
&lt;li&gt;Carol有了R之后自然可以领取到Bob的悬赏，得到了1.01个Btc，并将R交给了Bob&lt;/li&gt;
&lt;li&gt;Bob有了R之后自然可以领取到Alice的悬赏，得到了1.02个Btc，并将R交给了Alice&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://henta.github.io/post-images/1595320485399.png&#34; alt=&#34;HTLC&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上述是HTLC工作的简易流程，有以下几点需要补充说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总的来说HTLC的工作流程是&lt;mark&gt;将H正向传输，将R反向传输&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;流程图中的HTLC(1.02,200,H)三个参数分别指的是
&lt;ul&gt;
&lt;li&gt;支付1.02个Btc&lt;/li&gt;
&lt;li&gt;如果200个块之后依然没有人将R给我，我自己则可以回收这笔交易&lt;/li&gt;
&lt;li&gt;正向传输H给后继节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实际上，HTLC在闪电网络中的应用远没有如此简单，由于虫洞攻击并不复杂，这里并不对HTLC进行深入剖析。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;虫洞攻击&#34;&gt;虫洞攻击&lt;/h2&gt;
&lt;p&gt;我们看回到上面的图片中，可以发现如果进行正常的HTLC交易，Alice需要支付1.02个btc，Bob和Carol可以得到0.01Btc的报酬，Dave也可以正常得到1Btc。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;现在我们假设Dave和Bob是攻击者，Carol是无辜的受害者&lt;/li&gt;
&lt;li&gt;从HTLC的流程中可知Dave本应将R交给Carol，而现在Dave和Bob合谋，Dave直接将R给了Bob&lt;/li&gt;
&lt;li&gt;由于Carol一直没有得到R，在50个区块之后，他将步骤4中的HTLC取回了，Carol没有损失资金，也没有得到0.01Btc的手续费&lt;/li&gt;
&lt;li&gt;Bob得到R之后将R交给了Alice，得到了1.02个Btc，其中0.02Btc手续费（报酬）由于Carol没有将R给Bob，Bob在100个区块后将步骤3中的HTCL取回，到这里，我们可以看到Bob将Carol的手续费给私吞了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这就是虫洞攻击，事实上，合谋者之间有多少受害人，他们就可以获得多少受害人本应得到的手续费，目前所有使用HTLC进行建设的Layer-2都有这个问题&lt;/p&gt;
&lt;h2 id=&#34;解决方案-ptlc&#34;&gt;解决方案-PTLC&lt;/h2&gt;
&lt;p&gt;目前闪电网络团队正在试验一种新的多跳支付方式&lt;mark&gt;PTLC&lt;/mark&gt;来取代HTLC&lt;/p&gt;
&lt;p&gt;由于目前闪电网络团队还没有定论用哪种方式实现ptlc，因此对于ptlc暂时不做深入研究，以下仅对基本原理进行解析。以下解析依托于椭圆曲线知识，如果不熟悉或者忘记了可以看一看笔者对于椭圆曲线原理讲解的文章&lt;br&gt;
&lt;img src=&#34;https://suredbits.com/wp-content/uploads/2019/08/PaymentPoint.png&#34; alt=&#34;PTLC&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如上图所示，Alice需要经过Bob将btc发给Carol,进行分析前，需要确定以下几个共识：
&lt;ol&gt;
&lt;li&gt;PTLC基于椭圆曲线理论 ，a=b*G表示椭圆曲线上的乘法，知道b和G并不能倒推出a&lt;/li&gt;
&lt;li&gt;椭圆曲线上的乘法 加减法也符合交换律和结合律，如a&lt;em&gt;G+b&lt;/em&gt;G=(a+b)*G&lt;/li&gt;
&lt;li&gt;G是大家都知道的椭圆曲线上的一个点，在PTLC中，大家用的G都是相同的&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;首先，Alice生成两个随机数x，y，Carol生成一个随机数z&lt;/li&gt;
&lt;li&gt;Alice将(x+y)&lt;em&gt;G给了Carol，Carol将z&lt;/em&gt;G给了Alice，根据结合律,这时候Alice和Carol都能计算出(x+y+z)&lt;em&gt;G的值，但是Carol并不知道x&lt;/em&gt;G和y*G的值&lt;/li&gt;
&lt;li&gt;现在Alice发布一个PTLC的悬赏，悬赏内容是：谁能给我(x+z)&lt;em&gt;G我就给他0.11Btc；Bob看到后将这个悬赏接下了，与Alice建立了一个PTLC合约，Alice将y&lt;/em&gt;G发给了Bob&lt;/li&gt;
&lt;li&gt;现在Bob知道的是y*G,并不知道(x+z)*G，于是Bob找到了Carol，对他说，你把(x+z)*G的值给我，我就把Alice要求我付款的0.1个btc给你。但是Carol只知道(x+y)&lt;em&gt;G和z&lt;/em&gt;G的值，不知道Bob要的(x+z)*G，根据结合律，Carol也知道(x+y+z)*G的值，于是他把这个值给了Bob&lt;/li&gt;
&lt;li&gt;那么现在Bob知道了y*G和(x+y+z)*G的值，根据结合律，自然可以推出(x+z)*G的值，那么现在，他可以拿着这个值找Alice要悬赏了，Bob可以如愿以偿的获得0.11Btc，对比与支付给Carol的0.1Btc，Bob赚了0.01Btc的手续费。&lt;/li&gt;
&lt;li&gt;这个流程有意思的地方在于Carol并不能知道(x+z)&lt;em&gt;G的值，Bob到最后也没能知道x&lt;/em&gt;G、y*G、(x+y)*G的值，这可以防止在多跳网络中中间两者串通起来发动虫洞攻击，因为中间两者拥有的信息并不足以直接解除被攻击者设置的悬赏难题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考资料：&lt;br&gt;
闪电网络付款点（https://suredbits.com/payment-points-part-1/）&lt;br&gt;
虫洞攻击：一种针对支付通道网络的攻击（https://talk.nervos.org/t/topic/2672）&lt;/p&gt;
">闪电网络-虫洞攻击</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/bi-te-bi-jiao-yi-chang-jian-wen-ti/"" data-c="
          &lt;h1 id=&#34;比特币交易常见问题&#34;&gt;比特币交易常见问题&lt;/h1&gt;
&lt;h3 id=&#34;比特币私钥&#34;&gt;比特币私钥&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;原始私钥是32字节，也就是256位2进制数字，换算成16进制数字就是64位长度；&lt;/li&gt;
&lt;li&gt;私钥有16进制格式、WIF格式、WIF-compressed格式（WIF压缩格式）；&lt;/li&gt;
&lt;li&gt;WIF格式经过Base58check编码并以5作为前缀，WIF-compressed格式同样经过Base58Check编码并以K或L开头；&lt;/li&gt;
&lt;li&gt;私钥常常以WIF-compressed格式来展示，展示为以K或L开头的52位长度的数字和字母&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;椭圆曲线算法ecc&#34;&gt;椭圆曲线算法（ECC）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;椭圆曲线算法是不可逆的，很容易向一个方向计算，但是不可以向相反方向倒退；&lt;/li&gt;
&lt;li&gt;比特币采用了SECP256K1算法（椭圆曲线算法的一种），将私钥生成公钥。&lt;/li&gt;
&lt;li&gt;SECP256K1是不可逆的，所以即使公钥公开暴露，也对私钥的安全性不会造成影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;base64-base58check&#34;&gt;Base64、Base58Check&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Base64就是一种基于64个可打印字符来表示二进制数据的方法&lt;/li&gt;
&lt;li&gt;Base64字符集A~Z a~z 0~9+/&lt;/li&gt;
&lt;li&gt;Base58是用于比特币中的一种独特的编码方式，主要用于产生比特币钱包的地址&lt;/li&gt;
&lt;li&gt;相比Base64，Base58去除了一些容易混淆的相似字符：数字0和大写字母O，大写字母I和小写字母i，以及+和/&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;公钥私钥和比特币地址之间的关系&#34;&gt;公钥私钥和比特币地址之间的关系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;随机私钥生成公钥，公钥再生成比特币地址，且过程不可逆&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/01/30/5c5113448ae38.png&#34; alt=&#34;20190130110018-image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;utxounspent-transaction-outputs未花费交易输出&#34;&gt;UTXO（unspent transaction outputs，未花费交易输出）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用户比特币余额是用户钱包中可用的UTXO的总和。他们可能分布在数百个交易和区块中&lt;/li&gt;
&lt;li&gt;这些UTXO由用户所有的秘钥来控制花费行为。UTXO的面值为聪，是不可分割的价值单元，一个UTXO只能在一次交易中作为整体消耗&lt;/li&gt;
&lt;li&gt;每个比特币地址对应的UTXO，在交易过程中如同一张纸币一样（面额就是该比特币地址上的金额），不可以撕开使用，必须是作为一个整体来交易。&lt;/li&gt;
&lt;li&gt;未被交易的交易索引：检查inputs中的交易的txn是否在未被支付交易索引中即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;比特币交易验证&#34;&gt;比特币交易验证&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一笔交易就是一个地址的比特币，转移到另一个地址。由于比特币的交易记录全部是公开的，哪个地址拥有多少比特币，都是可以查到的。因此，支付方是否有足够的比特币，完成这笔交易，是很容易验证的。问题在于怎么防止其他人，冒用你的名义申报交易。&lt;/li&gt;
&lt;li&gt;申报交易的时候，除了交易金额，转出比特币的一方还必须提供以下数据。
&lt;ul&gt;
&lt;li&gt;上一笔交易的Hash（你从哪里得到的这些比特币）&lt;/li&gt;
&lt;li&gt;本次交易双方的地址&lt;/li&gt;
&lt;li&gt;支付方的公钥&lt;/li&gt;
&lt;li&gt;支付方的私钥生成的数字签名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;验证这笔交易是否属实，要经过三步
&lt;ul&gt;
&lt;li&gt;第一步，找到上一笔交易，确认支付方比特币的来源&lt;/li&gt;
&lt;li&gt;第二步，算出支付方公钥的指纹，确认与支付方的地址一致（因为通过公钥可以算出地址），从而保证公钥属实&lt;/li&gt;
&lt;li&gt;第三步，用公钥去解开数字签名（数字签名只有拥有私钥才能生成），保证签名属实，私钥属实。&lt;/li&gt;
&lt;li&gt;经过上面三步，就可以认定这笔交易是真实的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">比特币交易常见问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/bi-te-bi-qu-kuai-shu-ju-jie-gou/"" data-c="
          &lt;h2 id=&#34;区块相关信息&#34;&gt;区块相关信息&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;区块包括：区块头和区块体&lt;/li&gt;
&lt;li&gt;区块体记录了交易详情、交易计数器、区块大小&lt;/li&gt;
&lt;li&gt;区块头：每个区块的前&lt;mark&gt;80个字节（640bits）&lt;/mark&gt;，包含6部分信息
&lt;ul&gt;
&lt;li&gt;Version版本号，4字节&lt;/li&gt;
&lt;li&gt;前一个区块的hash值，32字节&lt;/li&gt;
&lt;li&gt;本区块所有交易的默克尔根，32字节&lt;/li&gt;
&lt;li&gt;时间戳，4字节
&lt;ul&gt;
&lt;li&gt;比特币是p2p网络，无中心服务器，每个节点的时间戳可能不同，因此有规定：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;新区快时间戳要大于前11个区块平均时间戳；&lt;/li&gt;
&lt;li&gt;不超过当前网络时间的两小时。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;所以后一个区块时间戳小于前一个也是有可能的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;难度Bits，4字节&lt;/li&gt;
&lt;li&gt;随机数Nonce，4字节
&lt;ul&gt;
&lt;li&gt;Nonce是全网矿工计算当前区块hash值得核心参数。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;Nonce的取值范围是0-2的32次方（42亿）&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">比特币区块数据结构</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/bi-te-bi-si-yao/"" data-c="
          &lt;h1 id=&#34;比特币私钥&#34;&gt;比特币私钥&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;原始私钥是32字节，也就是256位2进制数字，换算成16进制数字就是64位长度；&lt;/li&gt;
&lt;li&gt;私钥有16进制格式、WIF格式、WIF-compressed格式（WIF压缩格式）；&lt;/li&gt;
&lt;li&gt;WIF格式经过Base58check编码并以5作为前缀，WIF-compressed格式同样经过Base58Check编码并以K或L开头；&lt;/li&gt;
&lt;li&gt;私钥常常以WIF-compressed格式来展示，展示为以K或L开头的52位长度的数字和字母&lt;/li&gt;
&lt;/ul&gt;
">比特币私钥</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/bi-te-bi-jiao-yi-de-shu-ju-jie-gou/"" data-c="
          &lt;h1 id=&#34;比特币交易的数据结构&#34;&gt;比特币交易的数据结构&lt;/h1&gt;
&lt;hr&gt;
&lt;h3 id=&#34;比特币区块的结构&#34;&gt;比特币区块的结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每一个数据区块记录了5个内容：&lt;mark&gt;魔法数、区块大小、区块头信息、交易数量、交易详情&lt;/mark&gt;
&lt;ol&gt;
&lt;li&gt;魔法数（Magic no.）
&lt;ul&gt;
&lt;li&gt;占4字节&lt;/li&gt;
&lt;li&gt;正式网络中的魔法数：0xD9B4BEF9(实际区块中存储为小头位序，显示为 F9 BE B4 D9)&lt;/li&gt;
&lt;li&gt;测试网络中魔法数:0×07091108(实际区块中存储为小头位序,显示为0B 11 09 07）&lt;/li&gt;
&lt;li&gt;私链网络中魔法数:0xDAB5BFA(实际区块中存储为小头位序,显示为 FA BF B5 DA）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;区块大小(Blocksize)
&lt;ul&gt;
&lt;li&gt;占4字节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;区块头(Blockheader)
&lt;ul&gt;
&lt;li&gt;包含6个数据项,共占80字节&lt;/li&gt;
&lt;li&gt;区域版本号(Version),占4字节&lt;/li&gt;
&lt;li&gt;前一区块Hash(hashPrevBlock),占32字节&lt;/li&gt;
&lt;li&gt;Merkle根Hash,占32字节&lt;/li&gt;
&lt;li&gt;时间戳(Time),占4字节&lt;/li&gt;
&lt;li&gt;难度目标hash(bits),占4字节&lt;/li&gt;
&lt;li&gt;随机数( nonce),占4字节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交易数量（Transaction counter）
&lt;ul&gt;
&lt;li&gt;占1~9字节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交易详情（Transactions）
&lt;ul&gt;
&lt;li&gt;包含6个数据项，字节大小取决了交易中输入和输出的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;比特币交易的数据结构-2&#34;&gt;比特币交易的数据结构&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;交易数据格式的版本号(version)
&lt;ul&gt;
&lt;li&gt;占4字节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交易中输入的数量( tx_in_count)
&lt;ul&gt;
&lt;li&gt;占1-9字节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交易中输入的列表信息(tx_in)
&lt;ul&gt;
&lt;li&gt;最少占41字节&lt;/li&gt;
&lt;li&gt;标准的P2PKH交易的输入包含8项信息
&lt;ul&gt;
&lt;li&gt;上笔交易的hosh。占32字节&lt;/li&gt;
&lt;li&gt;该交易是上一笔交易的输出中的第几条。占4字节(索引下标从0开始)&lt;/li&gt;
&lt;li&gt;解锁脚本总长度。占106-108字节(私钥签名+压缩公钥的长度+2字节标记)&lt;/li&gt;
&lt;li&gt;私钥签名的长度。占1字节&lt;/li&gt;
&lt;li&gt;私钥签名的DER编码格式。占71~73字节&lt;/li&gt;
&lt;li&gt;压缩公钥的长度。占1字节&lt;/li&gt;
&lt;li&gt;压缩公钥。占33字节&lt;/li&gt;
&lt;li&gt;发送者定义的交易版本。就是JSON格式中的 sequence。占4字节。常用于识别交易的一个输入结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交易中输出的数量(tx_out_count)
&lt;ul&gt;
&lt;li&gt;占1~9字节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交易中输出的列表信息(tx_out)
&lt;ul&gt;
&lt;li&gt;最少占8字节&lt;/li&gt;
&lt;li&gt;交易的输出包含3项信息
&lt;ul&gt;
&lt;li&gt;交易金额。占8字节&lt;/li&gt;
&lt;li&gt;锁定脚本长度。至少占1字节&lt;/li&gt;
&lt;li&gt;锁定脚本内容。不定长度，根据脚本的复杂程度而可变长度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;锁定时间（lock_time）
&lt;ul&gt;
&lt;li&gt;占4字节&lt;/li&gt;
&lt;li&gt;锁定时间表示在某个高度的区块诞生之前或某个时间点之前，该交易出于锁定状态而不能被收录进区块链中。只有在满足锁定条件后才能打包上链。
&lt;ul&gt;
&lt;li&gt;lock_time==0,表示该交易可以立即被打包。&lt;/li&gt;
&lt;li&gt;lock_time&amp;lt;500000000,lock_time表示区块高度，就是说这笔交易只能被打包进高度大于lock_time的区块&lt;/li&gt;
&lt;li&gt;lock_time&amp;gt;=500000000,lock_time表示Unix时间戳，就是说这笔交易只能等待到当前时间大于lock_time&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;p2pkh交易的数据解析案例&#34;&gt;P2PKH交易的数据解析案例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;P2PKH交易的原始数据
&lt;ol&gt;
&lt;li&gt;原始记录：
&lt;ul&gt;
&lt;li&gt;交易记录的查询网址：https://blockchain.info/rawtx/ffc90e4b4ce15a97c1b560ad148da63cadaa898e366bf270ae307857a2606430?format=hex&lt;/li&gt;
&lt;li&gt;rawtx后面接交易id号format=hex表示以十六进制表示，不加就以json格式展示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交易记录的16进制文件
&lt;ul&gt;
&lt;li&gt;交易hash：ffc90e4b4ce15a97c1b560ad148da63cadaa898e366bf270ae307857a2606430&lt;/li&gt;
&lt;li&gt;16进制文件如下：0100000002738522d9350e2edb9fd7b287e78d89f361acbc4ddb8463b1a83f757103ad7f3d010000006b483045022100eae02b94ca5a88168327e4cc4a15256745658e5c1022e51f134d07c7c192f8d102207a527ee05457420661d2f8e583a69847fb86586c2206d57df121c7842117b672012103b66167e405a3b5483750cb21a14bff75d2080e1785dcfc21801f322382fb5ed5ffffffffbe5535e467861a3061f8a6ca30a6375ad14389425c77515092698d7fdd33544e010000006a4730440220689198269768623e755a5d9e617a70ffd045d4c9f99d859a8c609bff6cea0349022059d9da5c5737e407e45b5bc836161bff77eb5fae273899f0bc43bc98616e6683012102387d8b1a297e71327dc3f01137e8edcf66a2a7531935c2baca498726482529ceffffffff027cc5c800000000001976a9149bf3e6b720106f7a802fa5a84a461fa1c660163888ac80c3c9010000000017a914c4f45400fc2c1eeff8ae8fb709f9b9ce1eef952b8700000000&lt;/li&gt;
&lt;li&gt;计算机存储的16进制数据是小头位序排列格式，即低位在前，高位在后。区块链浏览器中16进制数值显示是大头位序排列形式，因为人们的读写习惯，数值从左至右读，左侧是大数，右侧是小数。所以在解析16进制文件时，需要将数据转成大头位序排列格式后再运算。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;交易数据结构解析
&lt;ol&gt;
&lt;li&gt;版本号
&lt;ul&gt;
&lt;li&gt;01000000 //转成大头位序排列为：00000001，所以版本号为1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交易中的输入数量
&lt;ul&gt;
&lt;li&gt;02 //输入数量为2个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交易中输入的列表信息
&lt;ol&gt;
&lt;li&gt;第一笔交易输入&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;上一笔交易的hash，占32字节 738522d9350e2edb9fd7b287e78d89f361acbc4ddb8463b1a83f757103ad7f3d&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;coinbase交易输出结构&#34;&gt;coinbase交易输出结构&lt;/h3&gt;
">比特币交易的数据结构</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/bi-te-bi-jiao-yi-he-qian-ming/"" data-c="
          &lt;h1 id=&#34;比特币交易和签名&#34;&gt;比特币交易和签名&lt;/h1&gt;
&lt;hr&gt;
&lt;h3 id=&#34;概述&#34;&gt;概述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;交易是比特币系统中最重要的部分&lt;/li&gt;
&lt;li&gt;每一笔交易的每一项输出严格意义上并不是指向一个地址，而是指向一个脚本
&lt;ul&gt;
&lt;li&gt;脚本类似一套规则，他约束着收币方必须满足一定条件才能花掉收币地址上锁定的资产。&lt;/li&gt;
&lt;li&gt;交易的本质是包含了一组输入和输出的数据结构，也就是转账记录。
&lt;ul&gt;
&lt;li&gt;输入和输出可以简单理解为：发币地址是输入，收币地址是输出。&lt;/li&gt;
&lt;li&gt;输入中包含解锁脚本（unlocking script）
&lt;ul&gt;
&lt;li&gt;解锁脚本是锁定脚本对应的脚本。锁定脚本相当于出了一个加密难题，而解锁脚本相当于是解开锁定脚本的一个题解。当解锁脚本满足锁定脚本要求的条件，就能花掉锁定脚本上对应的资产。用scripSig表示。&lt;/li&gt;
&lt;li&gt;简单的交易类型中的解锁脚本就是支付方用自己的私钥所做的签名。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;输出中包含锁定脚本（locking script）
&lt;ul&gt;
&lt;li&gt;交易输出中包含了交易的转账金额以及收币方的比特币地址。而锁定脚本就是在交易输出上附加了一个条件。&lt;/li&gt;
&lt;li&gt;由于锁定脚本往往含有一个公钥或者比特币地址，所以曾经就被称为公钥脚本。在代码中常用scriptPubKey表示。其实这种脚本技术存在更为广泛的可能性，更确切的叫法应该是锁定脚本&lt;/li&gt;
&lt;li&gt;在简单的交易类型中，锁定脚本中附加的条件就是收币方的公钥，将收币方的公钥与转账资产锁定在一起，意思就是只有拥有这个公钥的人才能解锁并有权花费其中的资产。&lt;/li&gt;
&lt;li&gt;要花费这笔被锁定的资产，就需要证明自己是锁定脚本里的那个公钥的所有者，最有利的证据就是用配套的私钥来证明，但是出于安全考虑，私钥是不能公开到网络中的，于是采用私钥生成的签名来代替私钥。如果签名与锁定资产的公钥相匹配，那么就有权花费这笔被锁定的资产。&lt;/li&gt;
&lt;li&gt;签名是通过secp256K1椭圆曲线加密算法实现的，知道签名也没有办法逆推出私钥，所以这是安全的签名方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;交易链&#34;&gt;交易链&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/01/30/5c51137a79df7.png&#34; alt=&#34;20190130110112-image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;前一笔交易的输出是一个加密难题，需要用这笔钱的时候，就需要在新交易中的输入中加入解锁脚本解开加密难题&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;签名序列化der&#34;&gt;签名序列化（DER）￼&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;什么是DER？
&lt;ol&gt;
&lt;li&gt;DER（Distinguish Encoding Rules，可辨别编码规则）&lt;/li&gt;
&lt;li&gt;椭圆曲线加密算法对数据签名可以产生由两个值组成的签名Sig，通常称为R和S&lt;/li&gt;
&lt;li&gt;计算出R和S后，需要使用DER国际标准编码方案，将其序列化为16进制字节码格式&lt;/li&gt;
&lt;li&gt;椭圆曲线的数字签名其实是R和S值的序列化字节码。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;签名格式分析如下图&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/01/30/5c51138d16449.png&#34; alt=&#34;20190130110131-image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;第二部分序列的长度值决定了数字签名的总长度
&lt;ul&gt;
&lt;li&gt;序列长度为44，签名总长度为71字节（142位16进制数字）&lt;/li&gt;
&lt;li&gt;序列长度为45，签名总长度为72字节（144位16进制数字）&lt;/li&gt;
&lt;li&gt;序列长度为46，签名总长度为73字节（146位16进制数字）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;secp256k1实现交易签名及签名验证&#34;&gt;Secp256K1实现交易签名及签名验证&lt;/h3&gt;
&lt;hr&gt;
&lt;h3 id=&#34;比特币交易生命周期&#34;&gt;比特币交易生命周期&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;交易流程就是交易的生命周期。区块链的交易并不是通常意义上的一手交钱一手交货的交易，而是转账。比特币的交易可以包含多个输入和输出。可以理解成一笔交易可以有多个银行卡的资金来源，并且一次交易可以转账给多个人。&lt;/li&gt;
&lt;li&gt;比特币交易的生命周期包括：创建交易、广播交易、打包交易、交易上链、交易回退。
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建交易：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支付方A的客户端钱包优先搜索A用户的UTXO列表信息，找寻A是否有足够的资金进行支付。&lt;/li&gt;
&lt;li&gt;如果A有UTXO，那么A需要用自己的私钥，对每一个UTXO做签名，同时附加上每一个UTXO对应的公钥，以证明自己对该笔资金具有使用权。这些信息附加在A的支付方地址上，这就是解锁脚本。&lt;/li&gt;
&lt;li&gt;A在给收币方B转账过程中，会在转账金额末尾附加一个加密难题，从而将该笔转账资金进行锁定，只有满足条件的人才有权使用该笔资金。这就是锁定脚本。锁定脚本中一般锁定的是收币方的公钥或者公钥hash。&lt;/li&gt;
&lt;li&gt;比特币交易中的每个输出可以设置多个加密难题，那么该输出下次被使用时就需要多个签名来解密。&lt;/li&gt;
&lt;li&gt;交易一旦被创建也就意味着交易的生命周期开始了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;广播交易：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比特币交易被创建后，会广播到比特币网络中，网络中邻近的全节点收到交易信息，先放到本地的内存，然后对交易进行验证。比如这笔交易的input中引用的交易是否属于UTXO。若验证不成功，则交易会被认为是invalid Transaction--无效交易。若验证成功后这些交易会被认为是Unconfirm Transation--未确认交易，”未确认交易“会被放置在节点的有效交易池中等待被打包。&lt;/li&gt;
&lt;li&gt;比特币是一种全网记账的系统,因此每笔交易发生后,会在全网广播。每一个收到交易的比持币节点都会首先验证交易,有效的交易将被传递到临近的节点,这确保了只有有效的交易才会在网络中传播,而无效的交易将会在第一个节点处就被废弃。周边的全节点接到这笔交易后,也一样先放入内存进行验证,验证通过再放入有效交易池中等待被打包。
&lt;ul&gt;
&lt;li&gt;钱包收到比特币，其实就是钱包检测到了可用的UTXO。通过钱包控制的秘钥，可以把这些UTXO花出去。因此，用户的比特币”余额“是指用户钱包中可用的UTXO总和。&lt;/li&gt;
&lt;li&gt;全节点客户端中, chainstate目录下的*.ldb文件中存放的就是UTXO记录。&lt;/li&gt;
&lt;li&gt;一个UTXO可以是1”聪“的任意整数倍。尽管UTXO可以是任意值，但一旦被创造出来，即不可分割。这是UTXO值得被强调的一个重要特性：一个UTXO只能在一次交易中作为一个整体被消耗。但是比特币系统也可以找零。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打包交易&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;挖矿节点每次开始挖矿就按一定的优先级次序从交易池中抽取近千笔未确认交易，打包进区块，打包时会将上一个区块的Hash值也加入包中。然后开始执行挖矿。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交易上链：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;争夺记账权:挖矿节点利用工作量证明来争夺记账权。当挖矿成功,该节点生成新区块后,整个过程并没有结束,该节点接下来会发起一次全网记账。&lt;/li&gt;
&lt;li&gt;全网记账:挖矿成功的节点,将新区块的数据记录在自己的硬盘上,并同时将数据广播至全网,周边的节点接收到之后再传递给其它周边的节点,直到全网都收到这个信息。接收到信息的节点对新区块数据进行核对。验证通过后,各个节点将该区块数据追加到比特币主链的最后端,其实就是记录到自己节点的硬盘中,这样来确保本地的区块链数据更新为最新的数据。&lt;/li&gt;
&lt;li&gt;更新交易池:挖矿节点在接收并验证新区块数据后,会检查自己内存池中的全部交易,移除已经在新区块中出现过的交易记录,确保任何留在内存池中的交易都是未确认的。而那些被移除的交易记录其实就获得了一次交易“确认”。&lt;/li&gt;
&lt;li&gt;更新UTXO索引:每一次交易都代表这UTXO集合的变化,交易结束,节点会更新UTXO索引。&lt;/li&gt;
&lt;li&gt;把包含在区块内且被添加到区块链上的交易称为“确认”交易,交易经过6次“确认”之后,就认为交易是安全不可更改的。此时交易接收方就能花费他在交易中得到的比特币。至此交易就永久被保存在了区块链上而不能被篡改和删除,也就意味着交易的生命周期结束了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交易回退：如果不巧出现临时分叉，则等到最长连诞生后，分叉的区块会断链并将其中记录的交易回退到交易池中，等待重新被打包上链。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
">比特币交易和签名</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/bi-te-bi-wa-kuang-yuan-li/"" data-c="
          &lt;h1 id=&#34;挖矿原理&#34;&gt;挖矿原理&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/01/30/5c51130ab6418.png&#34; alt=&#34;挖矿原理示意图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;挖矿的过程就是不断改变Nonce计算hash的过程&lt;/li&gt;
&lt;li&gt;以551675区块为例，模拟挖矿过程：
&lt;ul&gt;
&lt;li&gt;将区块头中的六个参数以16进制的&lt;mark&gt;小端结尾&lt;/mark&gt;方式连接在一起
&lt;ul&gt;
&lt;li&gt;小端结尾就是将字节颠倒顺序，在16进制表示中，2个16进制数值代表了1个字节，所以就两个两个的颠倒&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;版本号：0x20000000
&lt;ul&gt;
&lt;li&gt;version=&amp;quot;02000000&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上一块的hash：000000000000000000080f18263448e7d679c4ef5f2781a1272146556b824a54
&lt;ul&gt;
&lt;li&gt;pre_version=&amp;quot;544a826b55462127a181275fefc479d6e7483426180f08000000000000000000&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;merkle_root:2c16a0662dfbeec9d13d8d9bc54d995e47492e8baf8e6344e5617b1e70b4baf8
&lt;ul&gt;
&lt;li&gt;merkle_root=&amp;quot;f8bab4701e7b61e544638eaf8b2e49475e994dc59b8d3dd1c9eefb2d66a0162c&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间戳：1543275021（2018-11-27 07:30:21，转16进制为5bfc820d）
&lt;ul&gt;
&lt;li&gt;time_stamp=&amp;quot;0d82fc5b&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;难度目标Bits：388648495 16进制:172a4e2f
&lt;ul&gt;
&lt;li&gt;bits=&amp;quot;2f4e2a17&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Nonce: 3039957436 16进制：b53211bc
&lt;ul&gt;
&lt;li&gt;nonce=&amp;quot;bc1132b5&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;head_hex=version+pre_hash+merkle_root+time_stamp+bits+nonce=&lt;br&gt;
02000000544a826b55462127a181275fefc479d6e7483426180f08000000000000000000f8bab4701e7b61e544638eaf8b2e49475e994dc59b8d3dd1c9eefb2d66a0162c0d82fc5b2f4e2a17bc1132b5&lt;/li&gt;
&lt;li&gt;再计算两次hash256并且转码&lt;/li&gt;
&lt;li&gt;转回大端&lt;/li&gt;
&lt;li&gt;比对目标大小，需要实际计算的hash值&amp;lt;目标hash大小才算验证成功&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">比特币挖矿原理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/spring-ding-shi-ren-wu/"" data-c="
          &lt;h3 id=&#34;spring定时任务schedule&#34;&gt;spring定时任务Schedule&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;我们使用@Scheduled来创建定时任务，并通过在启动类上加上@EnableScheduling注解开启定时任务。 这个注解用来标注一个定时任务方法。通过看@Scheduled源码可以看出它支持多种参数：&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code&gt;1. cron：cron表达式，指定任务在特定时间执行；
2. fixedDelay：表示上一次任务执行完成后多久再次执行，参数类型为long，单位ms；
3. fixedDelayString：与fixedDelay含义一样，只是参数类型变为String；
4. fixedRate：表示按一定的频率执行任务，参数类型为long，单位ms；
5. fixedRateString: 与fixedRate的含义一样，只是将参数类型变为String；
6. initialDelay：表示延迟多久再第一次执行任务，参数类型为long，单位ms；
7. initialDelayString：与initialDelay的含义一样，只是将参数类型变为String；
8. zone：时区，默认为当前时区，一般没有用到。
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;定时任务默认是单线程启动的，想要多线程执行定时任务，可以做如下配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
//所有的定时任务都放在一个线程池中，定时任务启动时使用不同都线程。
public class ScheduleConfig implements SchedulingConfigurer {
    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        //设定一个长度10的定时任务线程池
        taskRegistrar.setScheduler(Executors.newScheduledThreadPool(10));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cron详解&#34;&gt;cron详解&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Cron表达式是一个字符串，是由空格隔开的6或7个域组成，每一个域对应一个含义（秒 分 时 每月第几天 月 星期 年）其中年是可选字段。 但是，spring的schedule值支持6个域的表达式，也就是不能设定年，如果超过六个则会报错。&lt;/li&gt;
&lt;li&gt;各域支持的类型：
&lt;ol&gt;
&lt;li&gt;秒：可出现&amp;quot;, - * /&amp;quot;四个字符，有效范围为0-59的整数&lt;/li&gt;
&lt;li&gt;分：可出现&amp;quot;, - * /&amp;quot;四个字符，有效范围为0-59的整数&lt;/li&gt;
&lt;li&gt;时：可出现&amp;quot;, - * /&amp;quot;四个字符，有效范围为0-23的整数&lt;/li&gt;
&lt;li&gt;每月第几天：可出现&amp;quot;, - * / ? L W C&amp;quot;八个字符，有效范围为0-31的整数&lt;/li&gt;
&lt;li&gt;月：可出现&amp;quot;, - * /&amp;quot;四个字符，有效范围为1-12的整数或JAN-DEc&lt;/li&gt;
&lt;li&gt;星期：可出现&amp;quot;, - * / ? L C #&amp;quot;四个字符，有效范围为1-7的整数或SUN-SAT两个范围。1表示星期天，2表示星期一， 依次类推&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;特殊字符含义
&lt;ol&gt;
&lt;li&gt;*:表示匹配该域的任意值，比如在秒*, 就表示每秒都会触发事件；&lt;/li&gt;
&lt;li&gt;? : 只能用在每月第几天和星期两个域。表示不指定值，当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“?”；&lt;/li&gt;
&lt;li&gt;-: 表示范围，例如在分域使用5-20，表示从5分到20分钟每分钟触发一次&lt;/li&gt;
&lt;li&gt;/: 表示起始时间开始触发，然后每隔固定时间触发一次，例如在分域使用5/20,则意味着5分，25分，45分，分别触发一次.&lt;/li&gt;
&lt;li&gt;,: 表示列出枚举值。例如：在分域使用5,20，则意味着在5和20分时触发一次&lt;/li&gt;
&lt;li&gt;L : 表示最后，只能出现在星期和每月第几天域，如果在星期域使用1L,意味着在最后的一个星期日触发&lt;/li&gt;
&lt;li&gt;W : 表示有效工作日(周一到周五),只能出现在每月第几日域，系统将在离指定日期的最近的有效工作日触发事件。注意一点，W的最近寻找不会跨过月份&lt;/li&gt;
&lt;li&gt;LW : 这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五&lt;/li&gt;
&lt;li&gt;#: 用于确定每个月第几个星期几，只能出现在每月第几天域。例如在1#3，表示某月的第三个星期日&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;例子
&lt;ol&gt;
&lt;li&gt;0 0 * * * *                    表示每小时0分0秒执行一次&lt;/li&gt;
&lt;li&gt;*/10 * * * * *                 表示每10秒执行一次&lt;/li&gt;
&lt;li&gt;0 0 8-10 * * *				表示每天8，9，10点执行&lt;/li&gt;
&lt;li&gt;0 0/30 8-10 * * *			表示每天8点到10点，每半小时执行&lt;/li&gt;
&lt;li&gt;0 0 9-17 * * MON-FRI			表示每周一至周五，9点到17点的0分0秒执行&lt;/li&gt;
&lt;li&gt;0 0 0 25 12 ?				表示每年圣诞节（12月25日）0时0分0秒执行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
">spring定时任务</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/tong-lei-diao-yong-dao-zhi-de-spring-shi-wu-shi-xiao/"" data-c="
          &lt;p&gt;本人在工作过程中发现项目有一块的事务不生效，遂进行了以下的探究。本文通过两个案例深入讲解事务失效的原因以及提供一些有效的解决方法&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h4 id=&#34;案例1&#34;&gt;案例1&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface AService {
    public void a();
    public void b();
}

@Service
public class AServiceImpl implements AService{

    public void a() {
        this.b();
    }

    @Transactional(rollbackFor={Exception.class})
       public void b() {
         insert();
         update();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;mark&gt;同类&lt;/mark&gt;中一个没有@Transaction的方法调用有@Transaction的方法时，事务将会失效&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原因&lt;br&gt;
根本原因在于spring对于事务的管理方式：spring使用aop去管理事务&lt;br&gt;
对于上述AServiceImpl，在运行时，spring会自动生成其代理类如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AServiceImplProxy implements AService{

    public void a() {
      //反射调用目标类的a方法
	AServiceImpl.a();
    }

    public void b() {
     //启动事务的代码
     begin;
     try{
       //反射调用目标类的b方法
        AServiceImpl.b();
     }catch{
	rollback;
     }
     //事务提交的代码
     commit;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/22/Gz3AvxIw1eXan9i.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在调用getBean(&amp;quot;AServiceImpl&amp;quot;).a()时，实际上执行的是AServiceImplProxy.a(),而AServiceImplProxy.a()调用的是源类中的a()方法，源类中a()再去调用b(),显而易见，并没有用到代理类中的AServiceImplProxy.b(),自然不会有事务管理。&lt;/p&gt;
&lt;h4 id=&#34;案例2&#34;&gt;案例2&lt;/h4&gt;
&lt;p&gt;a()有@Transaction b()有@Transaction或无@Transaction&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class AServiceImpl implements AService{
    @Transactional(rollbackFor={Exception.class})
    public void a() {
        this.b();
    }

    @Transactional(rollbackFor={Exception.class})
       public void b() {
         insert();
         update();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;其实原理流程和案例1的差不多，上层类调用a()时，只会开启对于a()的事务，b的事务并没有起作用，但是因为spring的机制，会将b()自动加入到a()的事务中，所以a()方法也将b()管理了起来。&lt;/li&gt;
&lt;li&gt;对于案例1，a()连事务都没有调用，自然也不会自动将b()管理到a()&lt;/li&gt;
&lt;li&gt;注意点：虽然a()的事务会将b()管理起来，但是其实在b()上的注解是失效的，也就是说如果你想用不同的事务传播机制(如这种PROPAGATION_SUPPORTS)，机制将会失效,rollbackFor也只能沿用a()定义的&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;解决方案&#34;&gt;解决方案&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;显式的事务编程(不推荐，丧失了aop的方便性)&lt;/li&gt;
&lt;li&gt;显式的调用代理类中的b()
&lt;ul&gt;
&lt;li&gt;将暴露Proxy类设置为true@EnableAspectJAutoProxy(exposeProxy = true)&lt;/li&gt;
&lt;li&gt;然后显式调用代理类的b()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Transactional(rollbackFor={Exception.class})

public void a() {

    ((AService) AopContext.currentProxy()).b();

    //即调用AOP代理对象的b方法即可执行事务切面进行事务增强

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种做法很方便，但是不能保证以后新添加的代码不出现相同的问题&lt;br&gt;
3. 进行接口下沉，避免出现案例1的情况&lt;br&gt;
- 将一些操作数据库的通用方法放到另外的service里，这样不会出现同类调用transaction的尴尬情况&lt;br&gt;
- 这种做法比较优雅，也能完全避免出现事务失效的情况&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;不仅仅是@Transaction注解，几乎所有与AOP有关的注解都存在上述的问题，工作中需要格外注意&lt;/li&gt;
&lt;li&gt;现在代码大部分情况都是案例2中的情况，小部分是案例1中的情况，以后写代码的时候如果需要对注解有格外的定义，要记住案例2的情况中，注解将会失效&lt;/li&gt;
&lt;li&gt;其实还是要在写代码的时候有规范意识，不要所有东西都写在一起，专业的类干专业的事&lt;/li&gt;
&lt;li&gt;查看mybatis和事务日志：&lt;br&gt;
logging.level.com.okcoin.vault.service.dao.mapper=debug&lt;br&gt;
logging.level.org.springframework.jdbc.datasource.DataSourceTransactionManager=debug&lt;/li&gt;
&lt;/ol&gt;
">同类调用导致的spring事务失效</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/shan-dian-wang-luo/"" data-c="
          &lt;h3 id=&#34;闪电网络基本概念和步骤&#34;&gt;闪电网络基本概念和步骤&lt;/h3&gt;
&lt;p&gt;闪电网络就是将btc的小额交易放到链下去进行，等到双方交易结束后再将最后的账单上链，中间的交易过程无需上链，可以做到秒到账且低手续费。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ol&gt;
&lt;li&gt;openChannel（建立交易通道）：A和B协商好双方投入的资金，然后在比特币链上创建一个2/2的多重签名交易，需要花费output需要双方共同签名&lt;/li&gt;
&lt;li&gt;开始交易：建立好通道后，双方可以通过这个链下的通道进行交易，在第一步双方投入的金额内，交易可以进行无线多次，这些交易都不上链，双方只会&amp;quot;记账&amp;quot;&lt;/li&gt;
&lt;li&gt;closeChannel（关闭交易通道）：双方交易结束后需要将最终的账单统合，并且共同去花费第1步的output，进行最终的上链过程&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/12/10/udfWicAGqV9X6UM.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题:这种想法虽然好，但是怎么保证双方诚信？如果最后A舍弃了自己剩余的0.3btc（可能是故意或者私钥丢了），就是不配合B去花费2/2的output，这样B就损失了0.7个btc。当初说好的给彼此之间一点信任呢？&lt;/p&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;首先，上述问题的根本在于output是2/2的脚本，需要两个人共同花费，对于陌生的交易双方来说，风险太大，所以闪电网络需要设计出任意一方都可以将output正确花费的方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A和B在openChannel后，都为那个2/2的output构建一笔新交易&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;图中[]表示现在还不具备的东西，R表示随机数，Ra表示A的随机数，Rb表示b的随机数，Revocable Sequence Maturity Contract (RSMC) 可撤销序列成熟合约&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/12/10/y8hN3tznLcdiGr4.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;A和B将各自签名好的交易互相交换，现在可以观察一下，A和B都可以将对方给的交易上链了，但是如果对方不同意的话，RSMC脚本只能通过等待1000个区块去花费了，这就是强制上链的惩罚，而对方同意的话，可以直接通过对方的签名去花费这个RSMC，也就是可以即时花费
&lt;ul&gt;
&lt;li&gt;RSMC的原理其实就是多签脚本，时间锁条件是用比特币自带的参数timelock实现，需要R解锁的条件是利用了Hash不可逆推实现，B先会给A R的hash让A去构建这个交易脚本，之后拥有R解锁这个hash合约&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样一来任一方都可以closeChannel，只不过分为和平关闭和强制关闭 这就是为什么双方都同意建立交易通道的原因：只要我愿意，我们的交易一定会上链&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;现在双方在交易通道里继续交易记账 比如，A支付给了B 0.1btc，这时候双方会重新签一个未完成交易给对方：&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/12/10/l4hZ28cRrODUAyN.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通道内转账更新账单其实就是双方更新签名交易&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题来了，现在A手里有两个时期的未上链交易，A一看，我肯定愿意把最开始双方都得0.5btc的交易签名上链啊，这时候B肯定不同意，但是A却强制上链了，A只需要等待1000个块确认就能使用0.5btc了，白赚了0.1btc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是闪电网络规定，废弃掉上一个账单的时候，你必须把自己的随机数R交给对方，那么再来看看这个规定后的场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A同样想要把0.5btc的那笔交易上链，假设他也这么做了，A需要等待1000个确认才能花费RSMC中的0.5btc，而这个时候B发现A干坏事了，由于A之前已经把Ra给了B，B可以直接通过Bsig+Ra的方式先一步使用RSMC脚本花费掉这0.5btc，这样一来B其实就拥有了1btc。 这也是闪电网络对不诚信节点的惩罚&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;上述的情况都是发生在A直接能连到B的情况下，但是闪电网络是一个巨大的网络，A并不能保证每次都能直接连到B，这时候C节点刚好连着B，于是A就将C节点当成中间人去和A交易&lt;br&gt;
比如：A要转0.1btc给D&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/12/10/7RBlPEJXe2gqHoi.png&#34; alt=&#34;title&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;Dave准备一个随机数R，并计算其哈希H，将H给了Alice&lt;/li&gt;
&lt;li&gt;Alice和Bob建立通道的时候约定，如果3天内Bob能给出R，那Alice给Bob0.102btc，超过3天，拿回这些币&lt;/li&gt;
&lt;li&gt;Bob和Carol建立通道的时候约定，如果2天内Carol能给出R，Bob就给Carol0.101btc&lt;/li&gt;
&lt;li&gt;Carol和Dave建立通道的时候约定，如果1天内Dave能给出R，Carol就给Dave0.1btc&lt;br&gt;
最终，Dave把自己拥有的R给了Carol拿到了0.1btc，Carol用这个R换到了Bob的0.101btc，而Bob用R换到了Alice的0.102btc 皆大欢喜。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述的流程就是闪电网络中的HTLC（Hashed Timelock Contract）哈希时间锁定合约来实现的，原理和上面差不多，比特币脚本是支持生成这种规则的output的&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;现在的闪电网络都是需要收款方先提供一个二维码或者code给付款者的，这个code包含的信息其实就有H、金额等信息&lt;/li&gt;
&lt;li&gt;技术方面逻辑都很清晰成熟，现在闪电网络的运行也比较平稳，还没有听说有丢币事件。&lt;/li&gt;
&lt;/ul&gt;
">闪电网络原理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://henta.github.io/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>



<script src="/media/js/cool.js"></script>



</html>