<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://henta.github.io</id>
    <title>Gridea</title>
    <updated>2020-08-26T10:32:00.224Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://henta.github.io"/>
    <link rel="self" href="https://henta.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://henta.github.io/images/avatar.png</logo>
    <icon>https://henta.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[椭圆曲线算法与其安全性探究]]></title>
        <id>https://henta.github.io/post/tuo-yuan-qu-xian-suan-fa-yu-qi-an-quan-xing-tan-jiu/</id>
        <link href="https://henta.github.io/post/tuo-yuan-qu-xian-suan-fa-yu-qi-an-quan-xing-tan-jiu/">
        </link>
        <updated>2020-07-29T06:34:21.000Z</updated>
        <content type="html"><![CDATA[<h3 id="什么是椭圆曲线">什么是椭圆曲线？</h3>
<ul>
<li>数学中，y<sup>2</sup>=x<sup>3</sup>+ax+b这种模型，称为椭圆曲线，根据a，b的变化，椭圆曲线也会呈现不同的形状</li>
<li>例如b=1，a取值范围从2到-3<br>
<img src="https://i.loli.net/2019/05/22/5ce4be022fcdd18765.png" alt="title" loading="lazy"></li>
<li>椭圆曲线相对x轴对称</li>
<li>椭圆曲线加法：
<ul>
<li>R=P+Q https://cdn.rawgit.com/andreacorbellini/ecc/920b29a/interactive/reals-add.html</li>
</ul>
</li>
<li>椭圆曲线的乘法：
<ul>
<li>R=nP 相当于n个P相加</li>
</ul>
</li>
<li>椭圆曲线的标量积：假设n有k位二进制，可以将R=np的时间复杂度从O(2<sup>k</sup>)减少到O(logn)或者O(k)</li>
<li>椭圆曲线的逆元：每个成员都有一个相反数，比如对于a来说，有a+b=0，那么b就是a的逆元</li>
<li><strong>以上知识具体网址</strong>：https://zhuanlan.zhihu.com/p/36326221</li>
</ul>
<h3 id="离散对数与ecdsa">离散对数与ecdsa</h3>
<ul>
<li>x=log<sub>2</sub>n这种称为对数运算，上述椭圆曲线R=nP如果已知R和P求n的话，也可以算一个对数运算（绝不是除法运算，椭圆曲线的运算符定义方式和实数是不一样的）</li>
<li>有一个等式b = a<sup>k</sup> mod p，如果已知a p b，求k那么这就是一个离散对数问题，离散对数问题非常难求，最易懂的方法是穷举法，用穷举法相当于a相乘k次，当k很大时，穷举法基本不可能穷举出正确的k。<strong>还有一些其他的求离散对数的方法</strong>：https://wenku.baidu.com/view/f6b9ceb9112de2bd960590c69ec3d5bbfd0adab3.html</li>
<li>ecdsa（椭圆曲线签名算法）其实就是运用了离散对数的难求性，它将椭圆曲线mod n，所以对于R=nP来说，已知R和P，求n是一个非常难的问题，eckey中，Q=kG,k是私钥（32位的随机数），G是椭圆曲线的基点（已知），Q公钥很容易就可以求得，但是从公钥逆推k却是一个离散对数问题，基本不可能逆推出来。</li>
<li>相关知识网址：http://open.163.com/movie/2012/10/C/S/M99VIFJA6_M9EDSFLCS.html</li>
</ul>
<h3 id="ecdsa椭圆曲线签名算法">ECDSA（椭圆曲线签名算法）</h3>
<ul>
<li>不同种类的ECDSA：secp256k1和ed25519，其实用的思想是一样的，只是用的椭圆曲线不同，不同的椭圆曲线离散对数难题的难度不同，ed25519号称效率比secp256k1更好。</li>
<li>ECDSA签名算法的工作流程
<ol>
<li>取一个范围在[1, n - 1]的随机数k</li>
<li>计算点P=kG</li>
<li>计算r = X<sub>P</sub> mod n   P坐标的X轴值</li>
<li>如果 r == 0，执行第一步</li>
<li>计算s = k<sup>-1</sup> (z + r*da) mod n （da是私钥，k<sup>-1</sup> 是 k 对n的逆元 z是hash值）</li>
<li>如果s==0，执行第一步</li>
<li>二元组（r，s）就是签名值</li>
<li>通过一定格式的封装在网络上传输，不是简单的r+s</li>
</ol>
</li>
<li>ECDSA签名验证流程
<ol>
<li>计算u1 = s<sup>-1</sup> * z mod n</li>
<li>计算u2 = s<sup>-1</sup> * r mod n</li>
<li>计算P = u1<em>G + u2</em>Ha  (Ha是公钥)</li>
</ol>
<blockquote>
<p>P=u1G+u2Ha=u1G+u2daG=(u1+u2da)G<br>
将u1和u2带入，P=(s<sup>-1</sup>z+s<sup>-1</sup>rda)G=s<sup>-1</sup>(z+rda)G<br>
我们得到这个等式。<br>
然后再看看这个等式：<br>
s = k<sup>-1</sup> (z + r<em>da) mod n<br>
两边乘以(s<sup>-1</sup> * k)<br>
得到 等式 k = s<sup>-1</sup> (z + r</em>da) mod n<br>
两边再乘以G，得到<br>
kG = s<sup>-1</sup>*(z + r *da)*G mod n = P<br>
换句话说，如果(r,s)是有客户端私钥签名Z得到，则我们通过u1,u2计算的到的P值得x分量和r相同。</p>
</blockquote>
<ol start="4">
<li>如果r == X<sub>P</sub> mod n，则验证正确</li>
</ol>
</li>
</ul>
<h3 id="k的安全性问题">k的安全性问题</h3>
<blockquote>
<p>s = k<sup>-1</sup> (z + r<em>da) mod n<br>
如果k不变的话<br>
s1 = k<sup>-1</sup> (z1 + r</em>da) mod n等式1<br>
s2= k<sup>-1</sup> (z2 + r*da) mod n等式2<br>
s1 -s2 = k<sup>-1</sup> (z1 - z2) mod n<br>
z1和z2 可以自己使用哈希算法对软件进行哈希能够获取到。s1和s2能够从前面值中获取到。所以k值就轻松的获取到了<br>
k = (s1 -s2)<sup>-1</sup> * (z1 -z2) mod n<br>
而得到k之后，将k随便带入s1或者s2都很容易求出da，也就是私钥</p>
</blockquote>
<ul>
<li>如果k不是固定，但是是可以预测的，那么也是同理可以很容易求出私钥，所以k很重要，一组不好的k是有几率泄漏你的私钥的</li>
<li>关于k有过一个惨痛的教训：所以的ps3当时签名的时候，用的是固定的k，结果没过几天就被破解了</li>
</ul>
<h3 id="为什么大部分币种签名的时候得到的s和r不变呢">为什么大部分币种签名的时候得到的s和r不变呢？</h3>
<ul>
<li>按照上述流程来，签名的时候k必须是一个随机数，但是实际上，我们对同一笔输入进行签名的时候，得到的结果总是不变的，看起来就像是k固定了一样，如果k是随机的，那应该是相同输入每次签名也是不同的</li>
<li>事实上，比特币用了RFC6979协议：https://www.8btc.com/article/38766</li>
</ul>
<blockquote>
<p>简单说，比特币中k=SHA256(da + HASH(message));<br>
也就是说，k的生成和私钥有关，这样k就是独一无二的了，其实k并不是要求一定随机，而是要求独特且不可被发现。<br>
如果仅仅是针对比特币而言，这个公式已经很好了，但考虑到RFC6979面向的是密码学（不仅仅是比特币）的统一规范，要考虑更多的复杂情况（更多曲线、更多参数、更多算法等），因此，实际上的RFC6979要比上述公式复杂得多，代码实现起来也要多得多。</p>
</blockquote>
<p>算法可以复杂，代码可以很长，但原理都一样，要用私钥来保证“保密”，要用消息来保证“唯一”，再使用确定的、不可逆的方法来进行运算，最终计算出来的k值就是安全的。</p>
<p>RFC6979算法的完整实现，Java语言可参考SpongyCastle中HMacDSAKCalculator类,事实上，比特币也是直接用了该类生成k</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Schnorr签名以及其带来的随机数问题]]></title>
        <id>https://henta.github.io/post/schnorr-qian-ming-yi-ji-qi-dai-lai-de-sui-ji-shu-wen-ti/</id>
        <link href="https://henta.github.io/post/schnorr-qian-ming-yi-ji-qi-dai-lai-de-sui-ji-shu-wen-ti/">
        </link>
        <updated>2020-07-29T06:24:34.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="schnorr">Schnorr</h3>
<ul>
<li>签名流程</li>
</ul>
<blockquote>
<p>Q = kG<br>
r = hash(Q, Ha, msg) mod n<br>
s = k - r * da mod n<br>
其中da是私钥,Ha是公钥</p>
</blockquote>
<ul>
<li>验证流程</li>
</ul>
<blockquote>
<p>s * G=Ha * hash(Q, Ha, msg)+Q<br>
如果相等的话，验证成功<br>
其中Ha是公钥</p>
</blockquote>
<h3 id="schnorr的优缺点">Schnorr的优缺点</h3>
<ul>
<li>多笔签名一起验证，提高效率
<ul>
<li>对于ECDSA来说，同时验证多笔签名只能一笔一笔的验证，但是对于Schnorr来说，可以多笔签名一起验证</li>
</ul>
<blockquote>
<p>(s1+s2+…+s1000)×G=(Q1+…+Q1000)+(hash(Q1,Ha1,msg1)×Ha1+ hash(Q2,Ha2,msg2)×Ha2+…+hash(Q1000,Ha1000,msg1000)×Ha1000)<br>
椭圆曲线其实是一个阿尔贝群，虽然它的运算符号特殊，但是也符合交换律，结合律等</p>
</blockquote>
<ul>
<li>一起验证签名可以降低计算难度</li>
</ul>
<blockquote>
<p>对比一下一起签名和一笔一笔签名有什么不同<br>
一起签名的情况下，对于1000笔签名来说，其实进行了很多加法+1001次乘法<br>
如果是分开签名则要进行2000次乘法<br>
椭圆曲线的乘法比加法慢的多的多，所以将乘法转为加法可以大大提升效率<br>
再观察一下ECDSA，1000笔签名需要1000次倒置和2000次点乘运算，理论上整理效率不如Schnorr算法</p>
</blockquote>
<ul>
<li>个人观点：这个优点我觉得不是很重要。。。。按照btc10分钟一个块，ecdsa验证顶多慢几s,没啥大影响</li>
</ul>
</li>
<li>秘钥聚合</li>
</ul>
<blockquote>
<p>https://www.8btc.com/article/359642<br>
使用schnorr签名，我们可以使用一对私钥 (pk1,pk2)，并以此生成一个共享公钥P=P1+P2=pk1×G+pk2×G，共享公钥可以用来解共享签名（r1+r2,s1+s2）<br>
schnorr秘钥聚合也经历了很多版本，最初的秘钥聚合有流氓攻击风险：https://bitcointechtalk.com/scaling-bitcoin-schnorr-signatures-abe3b5c275d1，现在基本</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="schnorr">Schnorr</h3>
<ul>
<li>签名流程</li>
</ul>
<blockquote>
<p>Q = kG<br>
r = hash(Q, Ha, msg) mod n<br>
s = k - r * da mod n<br>
其中da是私钥,Ha是公钥</p>
</blockquote>
<ul>
<li>验证流程</li>
</ul>
<blockquote>
<p>s * G=Ha * hash(Q, Ha, msg)+Q<br>
如果相等的话，验证成功<br>
其中Ha是公钥</p>
</blockquote>
<h3 id="schnorr的优缺点">Schnorr的优缺点</h3>
<ul>
<li>多笔签名一起验证，提高效率
<ul>
<li>对于ECDSA来说，同时验证多笔签名只能一笔一笔的验证，但是对于Schnorr来说，可以多笔签名一起验证</li>
</ul>
<blockquote>
<p>(s1+s2+…+s1000)×G=(Q1+…+Q1000)+(hash(Q1,Ha1,msg1)×Ha1+ hash(Q2,Ha2,msg2)×Ha2+…+hash(Q1000,Ha1000,msg1000)×Ha1000)<br>
椭圆曲线其实是一个阿尔贝群，虽然它的运算符号特殊，但是也符合交换律，结合律等</p>
</blockquote>
<ul>
<li>一起验证签名可以降低计算难度</li>
</ul>
<blockquote>
<p>对比一下一起签名和一笔一笔签名有什么不同<br>
一起签名的情况下，对于1000笔签名来说，其实进行了很多加法+1001次乘法<br>
如果是分开签名则要进行2000次乘法<br>
椭圆曲线的乘法比加法慢的多的多，所以将乘法转为加法可以大大提升效率<br>
再观察一下ECDSA，1000笔签名需要1000次倒置和2000次点乘运算，理论上整理效率不如Schnorr算法</p>
</blockquote>
<ul>
<li>个人观点：这个优点我觉得不是很重要。。。。按照btc10分钟一个块，ecdsa验证顶多慢几s,没啥大影响</li>
</ul>
</li>
<li>秘钥聚合</li>
</ul>
<blockquote>
<p>https://www.8btc.com/article/359642<br>
使用schnorr签名，我们可以使用一对私钥 (pk1,pk2)，并以此生成一个共享公钥P=P1+P2=pk1×G+pk2×G，共享公钥可以用来解共享签名（r1+r2,s1+s2）<br>
schnorr秘钥聚合也经历了很多版本，最初的秘钥聚合有流氓攻击风险：https://bitcointechtalk.com/scaling-bitcoin-schnorr-signatures-abe3b5c275d1，现在基本</p>
</blockquote>
<!-- more -->
<p>都是用Mu-sig这个实现</p>
<ol>
<li>减少空间占用
<ul>
<li>比特币的做法：我们希望能用两个或者多个私钥共同控制比特币，目前的做法是n-of-m多重签名脚本，多重签名的个数越多，链上需要包含的签名size就越大（但是有隔离见证）</li>
<li>使用schnorr签名，无论多少个私钥控制签名，只需要签一个名即可，可以节省空间</li>
</ul>
<blockquote>
<p>这虽然是个有点，但是这并不是很重要。。。</p>
</blockquote>
</li>
<li>增强隐私性
<ul>
<li>比特币多签P2SH几乎是无隐私的，P2SH地址以3开头，这使得区块链观察者可以识别网络中所有的P2SH交易，并且确定哪些对象参与了多签交易<br>
<img src="https://i.loli.net/2019/05/24/5ce75c0d425c728270.png" alt="title" loading="lazy"></li>
<li>Schnorr的秘钥聚合却可以保证用户的隐私性，因为它会将几个公钥聚合成一把，这样观察者就不知道到底有几个人参与签名，到底是谁参与签名<br>
<img src="https://i.loli.net/2019/05/24/5ce75d5c5c15155129.png" alt="title" loading="lazy"></li>
</ul>
</li>
</ol>
<ul>
<li>无法使用确定性k进行签名
<ul>
<li>比特币其实用的是一个确定性k，这个k也非常有安全保障，但是Schnorr却不能使用这种模式，如果使用可确定性k，哪怕它是和你的私钥挂钩，黑客也能通过签名获取你的私钥</li>
</ul>
<blockquote>
<p>假设有人入侵了我们的电脑并完全控制了两个私钥中的一个（假设叫da），因为是多签，攻击者拿到一个私钥暂时也无法发送交易<br>
但是当我们发送交易的时候需要da和db两把私钥，我们尝试像往常一样进行交易，我们准备一个未签名的交易和Q1 = k1G的值将他转移到硬件钱包进行离线签名，返回了（r1，s1）但是因为某些原因，我们发送交易的在线钱包并没有将交易发出去，这时候我们可能需要重新签名再尝试发送交易，这次我们使用了Q2=k2G发送到硬件钱包</p>
</blockquote>
</li>
</ul>
<h3 id="随机数">随机数</h3>
<p>Schnorr的k必须用随机数生成，那么产生随机数就成了一个难题<br>
linux上的随机数用的是/dev/random或者/dev/urandom</p>
<ul>
<li>熵：可以理解为系统的操作，系统的不同操作会产生不同的熵，如键盘的输入、鼠标的移动、内存的使用、文件的使用量、进程数量等等。这些熵可以看做是哲学意义上的随机，这些熵正是linux随机数的源头<br>
java默认使用/dev/random</li>
<li>/dev/random 在系统熵不够的情况下会阻塞，所以如果程序大量调用默认随机数，就会产生阻塞，一次阻塞个两三分钟还是很正常的</li>
<li>/dev/urandom 哪怕熵不够也不会阻塞</li>
<li>实际上/dev/random和/dev/urandom都是经过伪随机数生成器（CSPRNG）所得:http://www.linuxeden.com/a/48277</li>
</ul>
<p>别问，问就是用 /dev/urandom</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/05/27/5ceb67e212b6e34501.png" alt="title" loading="lazy"></figure>
<p>从图中看来，其实urandom就是直接拿熵池中的数据当seed生成大量随机数，而random会判断熵池够不够数量，够数量才会用CSPRNG生成，random会保证每次用的熵不同<br>
但其实哪怕是urandom，他的seed也不会是固定的，他会用新熵去“洗种”，所以urandom的安全性并不差</p>
<h3 id="为什么大部分币种生成私钥的时候没有随机数问题">为什么大部分币种生成私钥的时候没有随机数问题？</h3>
<p>其实他们也是从/dev/random拿的，不过他们只拿一次作为java程序中伪随机数生成器（类似CSPRNG）的seed，通过这个随机的seed，可以无限生成伪随机数，同一个seed产生的随机数是一样的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[闪电网络-虫洞攻击]]></title>
        <id>https://henta.github.io/post/shan-dian-wang-luo-chong-dong-gong-ji/</id>
        <link href="https://henta.github.io/post/shan-dian-wang-luo-chong-dong-gong-ji/">
        </link>
        <updated>2020-07-21T08:32:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="htlc">HTLC</h2>
<p>Alice的目标是要将1btc转给Dave，但是自己并没有与之相连的通道，这时候就要找到与Dave的通道连接的节点，间接将钱支付给Dave</p>
<ol>
<li>Dave创建一个随机数R，并且Hash（R），我们将其称为H，然后将H传输给Alice</li>
<li>Alice发布一个悬赏：也就是HTLC，悬赏的大致意思是:谁能将R给我，我就给谁1.02个btc</li>
<li>Bob接下了Alice的悬赏，但是Bob并没有R，所以Bob也发布了一个悬赏：谁能将R给我，我就给谁1.01个btc</li>
<li>Carol接下了Bob的悬赏，但是Carol也没有R，所以Carol发布悬赏：谁能将R给我，我就给谁1.00个btc，因为通道相连，Dave直接接下这个悬赏，并且将R给了Carol</li>
<li>Carol接收到了R</li>
<li>Carol有了R之后自然可以领取到Bob的悬赏，得到了1.01个Btc，并将R交给了Bob</li>
<li>Bob有了R之后自然可以领取到Alice的悬赏，得到了1.02个Btc，并将R交给了Alice</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://henta.github.io/post-images/1595320485399.png" alt="HTLC" loading="lazy"></figure>
<p>上述是HTLC工作的简易流程，有以下几点需要补充说明：</p>
<ul>
<li>总的来说HTLC的工作流程是<mark>将H正向传输，将R反向传输</mark></li>
<li>流程图中的HTLC(1.02,200,H)三个参数分别指的是
<ul>
<li>支付1.02个Btc</li>
<li>如果200个块之后依然没有人将R给我，我自己则可以回收这笔交易</li>
<li>正向传输H给后继节点</li>
</ul>
</li>
<li>实际上，HTLC在闪电网络中的应用远没有如此简单，由于虫洞攻击并不复杂，这里并不对HTLC进行深入剖析。</li>
</ul>
<h2 id="虫洞攻击">虫洞攻击</h2>
<p>我们看回到上面的图片中，可以发现如果进行正常的HTLC交易，Alice需要支付1.02个btc，Bob和Carol可以得到0.01Btc的报酬，Dave也可以正常得到1Btc。</p>
<ul>
<li>现在我们假设Dave和Bob是攻击者，Carol是无辜的受害者</li>
<li>从HTLC的流程中可知Dave本应将R交给Carol，而现在Dave和Bob合谋，Dave直接将R给了Bob</li>
<li>由于Carol一直没有得到R，在50个区块之后，他将步骤4中的HTLC取回了，Carol没有损失资金，也没有得到0.01Btc的手续费</li>
<li>Bob得到R之后将R交给了Alice，得到了1.02个Btc，其中0.02Btc手续费（报酬）由于Carol没有将R给Bob，Bob在100个区块后将步骤3中的HTCL取回，到这里，我们可以看到Bob将Carol的手续费给私吞了。</li>
</ul>
<p>这就是虫洞攻击，事实上，合谋者之间有多少受害人，他们就可以获得多少受害人本应得到的手续费，目前所有使用HTLC进行建设的Layer-2都有这个问题</p>
<h2 id="解决方案-ptlc">解决方案-PTLC</h2>
<p>目前闪电网络团队正在试验一种新的多跳支付方式<mark>PTLC</mark>来取代HTLC</p>
<p>由于目前闪电网络团队还没有定论用哪种方式实现ptlc，因此对于ptlc暂时不做深入研究，以下仅对基本原理进行解析。以下解析依托于椭圆曲线知识，如果不熟悉或者忘记了可以看一看笔者对于椭圆曲线原理讲解的文章<br>
<img src="https://suredbits.com/wp-content/uploads/2019/08/PaymentPoint.png" alt="PTLC" loading="lazy"></p>
<ul>
<li>如上图所示，Alice需要经过Bob将btc发给Carol,进行分析前，需要确定以下几个共识：
<ol>
<li>PTLC基于椭圆曲线理论 ，a=b*G表示椭圆曲线上的乘法，知道b和G并不能倒推出a</li>
<li>椭圆曲线上的乘法 加减法也符合交换律和结合律，如a<em>G+b</em>G=(a+b)*G</li>
<li>G是大家都知道的椭圆曲线上的一个点，在PTLC中，大家用的G都是相同的</li>
</ol>
</li>
</ul>
<ol>
<li>首先，Alice生成两个随机数x，y，Carol生成一个随机数z</li>
<li>Alice将(x+y)<em>G给了Carol，Carol将z</em>G给了Alice，根据结合律,这时候Alice和Carol都能计算出(x+y+z)<em>G的值，但是Carol并不知道x</em>G和y*G的值</li>
<li>现在Alice发布一个PTLC的悬赏，悬赏内容是：谁能给我(x+z)<em>G我就给他0.11Btc；Bob看到后将这个悬赏接下了，与Alice建立了一个PTLC合约，Alice将y</em>G发给了Bob</li>
<li>现在Bob知道的是y*G,并不知道(x+z)*G，于是Bob找到了Carol，对他说，你把(x+z)*G的值给我，我就把Alice要求我付款的0.1个btc给你。但是Carol只知道(x+y)<em>G和z</em>G的值，不知道Bob要的(x+z)*G，根据结合律，Carol也知道(x+y+z)*G的值，于是他把这个值给了Bob</li>
<li>那么现在Bob知道了y*G和(x+y+z)*G的值，根据结合律，自然可以推出(x+z)*G的值，那么现在，他可以拿着这个值找Alice要悬赏了，Bob可以如愿以偿的获得0.11Btc，对比与支付给Carol的0.1Btc，Bob赚了0.01Btc的手续费。</li>
<li>这个流程有意思的地方在于Carol并不能知道(x+z)<em>G的值，Bob到最后也没能知道x</em>G、y*G、(x+y)*G的值，这可以防止在多跳网络中中间两者串通起来发动虫洞攻击，因为中间两者拥有的信息并不足以直接解除被攻击者设置的悬赏难题。</li>
</ol>
<p>参考资料：<br>
闪电网络付款点（https://suredbits.com/payment-points-part-1/）<br>
虫洞攻击：一种针对支付通道网络的攻击（https://talk.nervos.org/t/topic/2672）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[比特币交易常见问题]]></title>
        <id>https://henta.github.io/post/bi-te-bi-jiao-yi-chang-jian-wen-ti/</id>
        <link href="https://henta.github.io/post/bi-te-bi-jiao-yi-chang-jian-wen-ti/">
        </link>
        <updated>2020-02-17T05:19:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="比特币交易常见问题">比特币交易常见问题</h1>
<h3 id="比特币私钥">比特币私钥</h3>
<ul>
<li>原始私钥是32字节，也就是256位2进制数字，换算成16进制数字就是64位长度；</li>
<li>私钥有16进制格式、WIF格式、WIF-compressed格式（WIF压缩格式）；</li>
<li>WIF格式经过Base58check编码并以5作为前缀，WIF-compressed格式同样经过Base58Check编码并以K或L开头；</li>
<li>私钥常常以WIF-compressed格式来展示，展示为以K或L开头的52位长度的数字和字母</li>
</ul>
<hr>
<h3 id="椭圆曲线算法ecc">椭圆曲线算法（ECC）</h3>
<ul>
<li>椭圆曲线算法是不可逆的，很容易向一个方向计算，但是不可以向相反方向倒退；</li>
<li>比特币采用了SECP256K1算法（椭圆曲线算法的一种），将私钥生成公钥。</li>
<li>SECP256K1是不可逆的，所以即使公钥公开暴露，也对私钥的安全性不会造成影响。</li>
</ul>
<hr>
<h3 id="base64-base58check">Base64、Base58Check</h3>
<ul>
<li>Base64就是一种基于64个可打印字符来表示二进制数据的方法</li>
<li>Base64字符集A~Z a~z 0~9+/</li>
<li>Base58是用于比特币中的一种独特的编码方式，主要用于产生比特币钱包的地址</li>
<li>相比Base64，Base58去除了一些容易混淆的相似字符：数字0和大写字母O，大写字母I和小写字母i，以及+和/</li>
</ul>
<hr>
<h3 id="公钥私钥和比特币地址之间的关系">公钥私钥和比特币地址之间的关系</h3>
<ul>
<li>随机私钥生成公钥，公钥再生成比特币地址，且过程不可逆<br>
<img src="https://i.loli.net/2019/01/30/5c5113448ae38.png" alt="20190130110018-image.png" loading="lazy"></li>
</ul>
<hr>
<h3 id="utxounspent-transaction-outputs未花费交易输出">UTXO（unspent transaction outputs，未花费交易输出）</h3>
<ul>
<li>用户比特币余额是用户钱包中可用的UTXO的总和。他们可能分布在数百个交易和区块中</li>
<li>这些UTXO由用户所有的秘钥来控制花费行为。UTXO的面值为聪，是不可分割的价值单元，一个UTXO只能在一次交易中作为整体消耗</li>
<li>每个比特币地址对应的UTXO，在交易过程中如同一张纸币一样（面额就是该比特币地址上的金额），不可以撕开使用，必须是作为一个整体来交易。</li>
<li>未被交易的交易索引：检查inputs中的交易的txn是否在未被支付交易索引中即可。</li>
</ul>
<hr>
<h3 id="比特币交易验证">比特币交易验证</h3>
<ul>
<li>一笔交易就是一个地址的比特币，转移到另一个地址。由于比特币的交易记录全部是公开的，哪个地址拥有多少比特币，都是可以查到的。因此，支付方是否有足够的比特币，完成这笔交易，是很容易验证的。问题在于怎么防止其他人，冒用你的名义申报交易。</li>
<li>申报交易的时候，除了交易金额，转出比特币的一方还必须提供以下数据。
<ul>
<li>上一笔交易的Hash（你从哪里得到的这些比特币）</li>
<li>本次交易双方的地址</li>
<li>支付方的公钥</li>
<li>支付方的私钥生成的数字签名</li>
</ul>
</li>
<li>验证这笔交易是否属实，要经过三步
<ul>
<li>第一步，找到上一笔交易，确认支付方比特币的来源</li>
<li>第二步，算出支付方公钥的指纹，确认与支付方的地址一致（因为通过公钥可以算出地址），从而保证公钥属实</li>
<li>第三步，用公钥去解开数字签名（数字签名只有拥有私钥才能生成），保证签名属实，私钥属实。</li>
<li>经过上面三步，就可以认定这笔交易是真实的</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[比特币区块数据结构]]></title>
        <id>https://henta.github.io/post/bi-te-bi-qu-kuai-shu-ju-jie-gou/</id>
        <link href="https://henta.github.io/post/bi-te-bi-qu-kuai-shu-ju-jie-gou/">
        </link>
        <updated>2020-02-17T05:18:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="区块相关信息">区块相关信息</h2>
<ul>
<li>区块包括：区块头和区块体</li>
<li>区块体记录了交易详情、交易计数器、区块大小</li>
<li>区块头：每个区块的前<mark>80个字节（640bits）</mark>，包含6部分信息
<ul>
<li>Version版本号，4字节</li>
<li>前一个区块的hash值，32字节</li>
<li>本区块所有交易的默克尔根，32字节</li>
<li>时间戳，4字节
<ul>
<li>比特币是p2p网络，无中心服务器，每个节点的时间戳可能不同，因此有规定：</li>
</ul>
<ol>
<li>新区快时间戳要大于前11个区块平均时间戳；</li>
<li>不超过当前网络时间的两小时。</li>
</ol>
<ul>
<li>所以后一个区块时间戳小于前一个也是有可能的。</li>
</ul>
</li>
<li>难度Bits，4字节</li>
<li>随机数Nonce，4字节
<ul>
<li>Nonce是全网矿工计算当前区块hash值得核心参数。</li>
<li><mark>Nonce的取值范围是0-2的32次方（42亿）</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[比特币私钥]]></title>
        <id>https://henta.github.io/post/bi-te-bi-si-yao/</id>
        <link href="https://henta.github.io/post/bi-te-bi-si-yao/">
        </link>
        <updated>2020-02-17T05:17:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="比特币私钥">比特币私钥</h1>
<ul>
<li>原始私钥是32字节，也就是256位2进制数字，换算成16进制数字就是64位长度；</li>
<li>私钥有16进制格式、WIF格式、WIF-compressed格式（WIF压缩格式）；</li>
<li>WIF格式经过Base58check编码并以5作为前缀，WIF-compressed格式同样经过Base58Check编码并以K或L开头；</li>
<li>私钥常常以WIF-compressed格式来展示，展示为以K或L开头的52位长度的数字和字母</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[比特币交易的数据结构]]></title>
        <id>https://henta.github.io/post/bi-te-bi-jiao-yi-de-shu-ju-jie-gou/</id>
        <link href="https://henta.github.io/post/bi-te-bi-jiao-yi-de-shu-ju-jie-gou/">
        </link>
        <updated>2020-02-17T05:17:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="比特币交易的数据结构">比特币交易的数据结构</h1>
<hr>
<h3 id="比特币区块的结构">比特币区块的结构</h3>
<ul>
<li>每一个数据区块记录了5个内容：<mark>魔法数、区块大小、区块头信息、交易数量、交易详情</mark>
<ol>
<li>魔法数（Magic no.）
<ul>
<li>占4字节</li>
<li>正式网络中的魔法数：0xD9B4BEF9(实际区块中存储为小头位序，显示为 F9 BE B4 D9)</li>
<li>测试网络中魔法数:0×07091108(实际区块中存储为小头位序,显示为0B 11 09 07）</li>
<li>私链网络中魔法数:0xDAB5BFA(实际区块中存储为小头位序,显示为 FA BF B5 DA）</li>
</ul>
</li>
<li>区块大小(Blocksize)
<ul>
<li>占4字节</li>
</ul>
</li>
<li>区块头(Blockheader)
<ul>
<li>包含6个数据项,共占80字节</li>
<li>区域版本号(Version),占4字节</li>
<li>前一区块Hash(hashPrevBlock),占32字节</li>
<li>Merkle根Hash,占32字节</li>
<li>时间戳(Time),占4字节</li>
<li>难度目标hash(bits),占4字节</li>
<li>随机数( nonce),占4字节</li>
</ul>
</li>
<li>交易数量（Transaction counter）
<ul>
<li>占1~9字节</li>
</ul>
</li>
<li>交易详情（Transactions）
<ul>
<li>包含6个数据项，字节大小取决了交易中输入和输出的数量</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="比特币交易的数据结构-2">比特币交易的数据结构</h3>
<ol>
<li>交易数据格式的版本号(version)
<ul>
<li>占4字节</li>
</ul>
</li>
<li>交易中输入的数量( tx_in_count)
<ul>
<li>占1-9字节</li>
</ul>
</li>
<li>交易中输入的列表信息(tx_in)
<ul>
<li>最少占41字节</li>
<li>标准的P2PKH交易的输入包含8项信息
<ul>
<li>上笔交易的hosh。占32字节</li>
<li>该交易是上一笔交易的输出中的第几条。占4字节(索引下标从0开始)</li>
<li>解锁脚本总长度。占106-108字节(私钥签名+压缩公钥的长度+2字节标记)</li>
<li>私钥签名的长度。占1字节</li>
<li>私钥签名的DER编码格式。占71~73字节</li>
<li>压缩公钥的长度。占1字节</li>
<li>压缩公钥。占33字节</li>
<li>发送者定义的交易版本。就是JSON格式中的 sequence。占4字节。常用于识别交易的一个输入结束。</li>
</ul>
</li>
</ul>
</li>
<li>交易中输出的数量(tx_out_count)
<ul>
<li>占1~9字节</li>
</ul>
</li>
<li>交易中输出的列表信息(tx_out)
<ul>
<li>最少占8字节</li>
<li>交易的输出包含3项信息
<ul>
<li>交易金额。占8字节</li>
<li>锁定脚本长度。至少占1字节</li>
<li>锁定脚本内容。不定长度，根据脚本的复杂程度而可变长度</li>
</ul>
</li>
</ul>
</li>
<li>锁定时间（lock_time）
<ul>
<li>占4字节</li>
<li>锁定时间表示在某个高度的区块诞生之前或某个时间点之前，该交易出于锁定状态而不能被收录进区块链中。只有在满足锁定条件后才能打包上链。
<ul>
<li>lock_time==0,表示该交易可以立即被打包。</li>
<li>lock_time&lt;500000000,lock_time表示区块高度，就是说这笔交易只能被打包进高度大于lock_time的区块</li>
<li>lock_time&gt;=500000000,lock_time表示Unix时间戳，就是说这笔交易只能等待到当前时间大于lock_time</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="p2pkh交易的数据解析案例">P2PKH交易的数据解析案例</h3>
<ul>
<li>P2PKH交易的原始数据
<ol>
<li>原始记录：
<ul>
<li>交易记录的查询网址：https://blockchain.info/rawtx/ffc90e4b4ce15a97c1b560ad148da63cadaa898e366bf270ae307857a2606430?format=hex</li>
<li>rawtx后面接交易id号format=hex表示以十六进制表示，不加就以json格式展示</li>
</ul>
</li>
<li>交易记录的16进制文件
<ul>
<li>交易hash：ffc90e4b4ce15a97c1b560ad148da63cadaa898e366bf270ae307857a2606430</li>
<li>16进制文件如下：0100000002738522d9350e2edb9fd7b287e78d89f361acbc4ddb8463b1a83f757103ad7f3d010000006b483045022100eae02b94ca5a88168327e4cc4a15256745658e5c1022e51f134d07c7c192f8d102207a527ee05457420661d2f8e583a69847fb86586c2206d57df121c7842117b672012103b66167e405a3b5483750cb21a14bff75d2080e1785dcfc21801f322382fb5ed5ffffffffbe5535e467861a3061f8a6ca30a6375ad14389425c77515092698d7fdd33544e010000006a4730440220689198269768623e755a5d9e617a70ffd045d4c9f99d859a8c609bff6cea0349022059d9da5c5737e407e45b5bc836161bff77eb5fae273899f0bc43bc98616e6683012102387d8b1a297e71327dc3f01137e8edcf66a2a7531935c2baca498726482529ceffffffff027cc5c800000000001976a9149bf3e6b720106f7a802fa5a84a461fa1c660163888ac80c3c9010000000017a914c4f45400fc2c1eeff8ae8fb709f9b9ce1eef952b8700000000</li>
<li>计算机存储的16进制数据是小头位序排列格式，即低位在前，高位在后。区块链浏览器中16进制数值显示是大头位序排列形式，因为人们的读写习惯，数值从左至右读，左侧是大数，右侧是小数。所以在解析16进制文件时，需要将数据转成大头位序排列格式后再运算。</li>
</ul>
</li>
</ol>
</li>
<li>交易数据结构解析
<ol>
<li>版本号
<ul>
<li>01000000 //转成大头位序排列为：00000001，所以版本号为1</li>
</ul>
</li>
<li>交易中的输入数量
<ul>
<li>02 //输入数量为2个</li>
</ul>
</li>
<li>交易中输入的列表信息
<ol>
<li>第一笔交易输入</li>
</ol>
<ul>
<li>上一笔交易的hash，占32字节 738522d9350e2edb9fd7b287e78d89f361acbc4ddb8463b1a83f757103ad7f3d</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="coinbase交易输出结构">coinbase交易输出结构</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[比特币交易和签名]]></title>
        <id>https://henta.github.io/post/bi-te-bi-jiao-yi-he-qian-ming/</id>
        <link href="https://henta.github.io/post/bi-te-bi-jiao-yi-he-qian-ming/">
        </link>
        <updated>2020-02-17T05:15:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="比特币交易和签名">比特币交易和签名</h1>
<hr>
<h3 id="概述">概述</h3>
<ul>
<li>交易是比特币系统中最重要的部分</li>
<li>每一笔交易的每一项输出严格意义上并不是指向一个地址，而是指向一个脚本
<ul>
<li>脚本类似一套规则，他约束着收币方必须满足一定条件才能花掉收币地址上锁定的资产。</li>
<li>交易的本质是包含了一组输入和输出的数据结构，也就是转账记录。
<ul>
<li>输入和输出可以简单理解为：发币地址是输入，收币地址是输出。</li>
<li>输入中包含解锁脚本（unlocking script）
<ul>
<li>解锁脚本是锁定脚本对应的脚本。锁定脚本相当于出了一个加密难题，而解锁脚本相当于是解开锁定脚本的一个题解。当解锁脚本满足锁定脚本要求的条件，就能花掉锁定脚本上对应的资产。用scripSig表示。</li>
<li>简单的交易类型中的解锁脚本就是支付方用自己的私钥所做的签名。</li>
</ul>
</li>
<li>输出中包含锁定脚本（locking script）
<ul>
<li>交易输出中包含了交易的转账金额以及收币方的比特币地址。而锁定脚本就是在交易输出上附加了一个条件。</li>
<li>由于锁定脚本往往含有一个公钥或者比特币地址，所以曾经就被称为公钥脚本。在代码中常用scriptPubKey表示。其实这种脚本技术存在更为广泛的可能性，更确切的叫法应该是锁定脚本</li>
<li>在简单的交易类型中，锁定脚本中附加的条件就是收币方的公钥，将收币方的公钥与转账资产锁定在一起，意思就是只有拥有这个公钥的人才能解锁并有权花费其中的资产。</li>
<li>要花费这笔被锁定的资产，就需要证明自己是锁定脚本里的那个公钥的所有者，最有利的证据就是用配套的私钥来证明，但是出于安全考虑，私钥是不能公开到网络中的，于是采用私钥生成的签名来代替私钥。如果签名与锁定资产的公钥相匹配，那么就有权花费这笔被锁定的资产。</li>
<li>签名是通过secp256K1椭圆曲线加密算法实现的，知道签名也没有办法逆推出私钥，所以这是安全的签名方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="交易链">交易链</h3>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/01/30/5c51137a79df7.png" alt="20190130110112-image.png" loading="lazy"></figure>
<ul>
<li>前一笔交易的输出是一个加密难题，需要用这笔钱的时候，就需要在新交易中的输入中加入解锁脚本解开加密难题</li>
</ul>
<hr>
<h3 id="签名序列化der">签名序列化（DER）￼</h3>
<ul>
<li>什么是DER？
<ol>
<li>DER（Distinguish Encoding Rules，可辨别编码规则）</li>
<li>椭圆曲线加密算法对数据签名可以产生由两个值组成的签名Sig，通常称为R和S</li>
<li>计算出R和S后，需要使用DER国际标准编码方案，将其序列化为16进制字节码格式</li>
<li>椭圆曲线的数字签名其实是R和S值的序列化字节码。</li>
</ol>
</li>
<li>签名格式分析如下图<br>
<img src="https://i.loli.net/2019/01/30/5c51138d16449.png" alt="20190130110131-image.png" loading="lazy"></li>
<li>第二部分序列的长度值决定了数字签名的总长度
<ul>
<li>序列长度为44，签名总长度为71字节（142位16进制数字）</li>
<li>序列长度为45，签名总长度为72字节（144位16进制数字）</li>
<li>序列长度为46，签名总长度为73字节（146位16进制数字）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="secp256k1实现交易签名及签名验证">Secp256K1实现交易签名及签名验证</h3>
<hr>
<h3 id="比特币交易生命周期">比特币交易生命周期</h3>
<ul>
<li>交易流程就是交易的生命周期。区块链的交易并不是通常意义上的一手交钱一手交货的交易，而是转账。比特币的交易可以包含多个输入和输出。可以理解成一笔交易可以有多个银行卡的资金来源，并且一次交易可以转账给多个人。</li>
<li>比特币交易的生命周期包括：创建交易、广播交易、打包交易、交易上链、交易回退。
<ol>
<li>
<p>创建交易：</p>
<ul>
<li>支付方A的客户端钱包优先搜索A用户的UTXO列表信息，找寻A是否有足够的资金进行支付。</li>
<li>如果A有UTXO，那么A需要用自己的私钥，对每一个UTXO做签名，同时附加上每一个UTXO对应的公钥，以证明自己对该笔资金具有使用权。这些信息附加在A的支付方地址上，这就是解锁脚本。</li>
<li>A在给收币方B转账过程中，会在转账金额末尾附加一个加密难题，从而将该笔转账资金进行锁定，只有满足条件的人才有权使用该笔资金。这就是锁定脚本。锁定脚本中一般锁定的是收币方的公钥或者公钥hash。</li>
<li>比特币交易中的每个输出可以设置多个加密难题，那么该输出下次被使用时就需要多个签名来解密。</li>
<li>交易一旦被创建也就意味着交易的生命周期开始了</li>
</ul>
</li>
<li>
<p>广播交易：</p>
<ul>
<li>比特币交易被创建后，会广播到比特币网络中，网络中邻近的全节点收到交易信息，先放到本地的内存，然后对交易进行验证。比如这笔交易的input中引用的交易是否属于UTXO。若验证不成功，则交易会被认为是invalid Transaction--无效交易。若验证成功后这些交易会被认为是Unconfirm Transation--未确认交易，”未确认交易“会被放置在节点的有效交易池中等待被打包。</li>
<li>比特币是一种全网记账的系统,因此每笔交易发生后,会在全网广播。每一个收到交易的比持币节点都会首先验证交易,有效的交易将被传递到临近的节点,这确保了只有有效的交易才会在网络中传播,而无效的交易将会在第一个节点处就被废弃。周边的全节点接到这笔交易后,也一样先放入内存进行验证,验证通过再放入有效交易池中等待被打包。
<ul>
<li>钱包收到比特币，其实就是钱包检测到了可用的UTXO。通过钱包控制的秘钥，可以把这些UTXO花出去。因此，用户的比特币”余额“是指用户钱包中可用的UTXO总和。</li>
<li>全节点客户端中, chainstate目录下的*.ldb文件中存放的就是UTXO记录。</li>
<li>一个UTXO可以是1”聪“的任意整数倍。尽管UTXO可以是任意值，但一旦被创造出来，即不可分割。这是UTXO值得被强调的一个重要特性：一个UTXO只能在一次交易中作为一个整体被消耗。但是比特币系统也可以找零。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>打包交易</p>
<ul>
<li>挖矿节点每次开始挖矿就按一定的优先级次序从交易池中抽取近千笔未确认交易，打包进区块，打包时会将上一个区块的Hash值也加入包中。然后开始执行挖矿。</li>
</ul>
</li>
<li>
<p>交易上链：</p>
<ul>
<li>争夺记账权:挖矿节点利用工作量证明来争夺记账权。当挖矿成功,该节点生成新区块后,整个过程并没有结束,该节点接下来会发起一次全网记账。</li>
<li>全网记账:挖矿成功的节点,将新区块的数据记录在自己的硬盘上,并同时将数据广播至全网,周边的节点接收到之后再传递给其它周边的节点,直到全网都收到这个信息。接收到信息的节点对新区块数据进行核对。验证通过后,各个节点将该区块数据追加到比特币主链的最后端,其实就是记录到自己节点的硬盘中,这样来确保本地的区块链数据更新为最新的数据。</li>
<li>更新交易池:挖矿节点在接收并验证新区块数据后,会检查自己内存池中的全部交易,移除已经在新区块中出现过的交易记录,确保任何留在内存池中的交易都是未确认的。而那些被移除的交易记录其实就获得了一次交易“确认”。</li>
<li>更新UTXO索引:每一次交易都代表这UTXO集合的变化,交易结束,节点会更新UTXO索引。</li>
<li>把包含在区块内且被添加到区块链上的交易称为“确认”交易,交易经过6次“确认”之后,就认为交易是安全不可更改的。此时交易接收方就能花费他在交易中得到的比特币。至此交易就永久被保存在了区块链上而不能被篡改和删除,也就意味着交易的生命周期结束了。</li>
</ul>
</li>
<li>
<p>交易回退：如果不巧出现临时分叉，则等到最长连诞生后，分叉的区块会断链并将其中记录的交易回退到交易池中，等待重新被打包上链。</p>
</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[比特币挖矿原理]]></title>
        <id>https://henta.github.io/post/bi-te-bi-wa-kuang-yuan-li/</id>
        <link href="https://henta.github.io/post/bi-te-bi-wa-kuang-yuan-li/">
        </link>
        <updated>2020-02-17T05:14:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="挖矿原理">挖矿原理</h1>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/01/30/5c51130ab6418.png" alt="挖矿原理示意图" loading="lazy"></figure>
<ul>
<li>挖矿的过程就是不断改变Nonce计算hash的过程</li>
<li>以551675区块为例，模拟挖矿过程：
<ul>
<li>将区块头中的六个参数以16进制的<mark>小端结尾</mark>方式连接在一起
<ul>
<li>小端结尾就是将字节颠倒顺序，在16进制表示中，2个16进制数值代表了1个字节，所以就两个两个的颠倒</li>
</ul>
</li>
<li>版本号：0x20000000
<ul>
<li>version=&quot;02000000&quot;</li>
</ul>
</li>
<li>上一块的hash：000000000000000000080f18263448e7d679c4ef5f2781a1272146556b824a54
<ul>
<li>pre_version=&quot;544a826b55462127a181275fefc479d6e7483426180f08000000000000000000&quot;</li>
</ul>
</li>
<li>merkle_root:2c16a0662dfbeec9d13d8d9bc54d995e47492e8baf8e6344e5617b1e70b4baf8
<ul>
<li>merkle_root=&quot;f8bab4701e7b61e544638eaf8b2e49475e994dc59b8d3dd1c9eefb2d66a0162c&quot;</li>
</ul>
</li>
<li>时间戳：1543275021（2018-11-27 07:30:21，转16进制为5bfc820d）
<ul>
<li>time_stamp=&quot;0d82fc5b&quot;</li>
</ul>
</li>
<li>难度目标Bits：388648495 16进制:172a4e2f
<ul>
<li>bits=&quot;2f4e2a17&quot;</li>
</ul>
</li>
<li>Nonce: 3039957436 16进制：b53211bc
<ul>
<li>nonce=&quot;bc1132b5&quot;</li>
</ul>
</li>
<li>head_hex=version+pre_hash+merkle_root+time_stamp+bits+nonce=<br>
02000000544a826b55462127a181275fefc479d6e7483426180f08000000000000000000f8bab4701e7b61e544638eaf8b2e49475e994dc59b8d3dd1c9eefb2d66a0162c0d82fc5b2f4e2a17bc1132b5</li>
<li>再计算两次hash256并且转码</li>
<li>转回大端</li>
<li>比对目标大小，需要实际计算的hash值&lt;目标hash大小才算验证成功</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[spring定时任务]]></title>
        <id>https://henta.github.io/post/spring-ding-shi-ren-wu/</id>
        <link href="https://henta.github.io/post/spring-ding-shi-ren-wu/">
        </link>
        <updated>2019-12-18T07:31:25.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="spring定时任务schedule">spring定时任务Schedule</h3>
<ul>
<li>我们使用@Scheduled来创建定时任务，并通过在启动类上加上@EnableScheduling注解开启定时任务。 这个注解用来标注一个定时任务方法。通过看@Scheduled源码可以看出它支持多种参数：</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h3 id="spring定时任务schedule">spring定时任务Schedule</h3>
<ul>
<li>我们使用@Scheduled来创建定时任务，并通过在启动类上加上@EnableScheduling注解开启定时任务。 这个注解用来标注一个定时任务方法。通过看@Scheduled源码可以看出它支持多种参数：</li>
</ul>
<!-- more -->
<pre><code>1. cron：cron表达式，指定任务在特定时间执行；
2. fixedDelay：表示上一次任务执行完成后多久再次执行，参数类型为long，单位ms；
3. fixedDelayString：与fixedDelay含义一样，只是参数类型变为String；
4. fixedRate：表示按一定的频率执行任务，参数类型为long，单位ms；
5. fixedRateString: 与fixedRate的含义一样，只是将参数类型变为String；
6. initialDelay：表示延迟多久再第一次执行任务，参数类型为long，单位ms；
7. initialDelayString：与initialDelay的含义一样，只是将参数类型变为String；
8. zone：时区，默认为当前时区，一般没有用到。
</code></pre>
<ul>
<li>定时任务默认是单线程启动的，想要多线程执行定时任务，可以做如下配置</li>
</ul>
<pre><code class="language-java">@Configuration
//所有的定时任务都放在一个线程池中，定时任务启动时使用不同都线程。
public class ScheduleConfig implements SchedulingConfigurer {
    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        //设定一个长度10的定时任务线程池
        taskRegistrar.setScheduler(Executors.newScheduledThreadPool(10));
    }
}
</code></pre>
<h3 id="cron详解">cron详解</h3>
<ul>
<li>Cron表达式是一个字符串，是由空格隔开的6或7个域组成，每一个域对应一个含义（秒 分 时 每月第几天 月 星期 年）其中年是可选字段。 但是，spring的schedule值支持6个域的表达式，也就是不能设定年，如果超过六个则会报错。</li>
<li>各域支持的类型：
<ol>
<li>秒：可出现&quot;, - * /&quot;四个字符，有效范围为0-59的整数</li>
<li>分：可出现&quot;, - * /&quot;四个字符，有效范围为0-59的整数</li>
<li>时：可出现&quot;, - * /&quot;四个字符，有效范围为0-23的整数</li>
<li>每月第几天：可出现&quot;, - * / ? L W C&quot;八个字符，有效范围为0-31的整数</li>
<li>月：可出现&quot;, - * /&quot;四个字符，有效范围为1-12的整数或JAN-DEc</li>
<li>星期：可出现&quot;, - * / ? L C #&quot;四个字符，有效范围为1-7的整数或SUN-SAT两个范围。1表示星期天，2表示星期一， 依次类推</li>
</ol>
</li>
<li>特殊字符含义
<ol>
<li>*:表示匹配该域的任意值，比如在秒*, 就表示每秒都会触发事件；</li>
<li>? : 只能用在每月第几天和星期两个域。表示不指定值，当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“?”；</li>
<li>-: 表示范围，例如在分域使用5-20，表示从5分到20分钟每分钟触发一次</li>
<li>/: 表示起始时间开始触发，然后每隔固定时间触发一次，例如在分域使用5/20,则意味着5分，25分，45分，分别触发一次.</li>
<li>,: 表示列出枚举值。例如：在分域使用5,20，则意味着在5和20分时触发一次</li>
<li>L : 表示最后，只能出现在星期和每月第几天域，如果在星期域使用1L,意味着在最后的一个星期日触发</li>
<li>W : 表示有效工作日(周一到周五),只能出现在每月第几日域，系统将在离指定日期的最近的有效工作日触发事件。注意一点，W的最近寻找不会跨过月份</li>
<li>LW : 这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五</li>
<li>#: 用于确定每个月第几个星期几，只能出现在每月第几天域。例如在1#3，表示某月的第三个星期日</li>
</ol>
</li>
<li>例子
<ol>
<li>0 0 * * * *                    表示每小时0分0秒执行一次</li>
<li>*/10 * * * * *                 表示每10秒执行一次</li>
<li>0 0 8-10 * * *				表示每天8，9，10点执行</li>
<li>0 0/30 8-10 * * *			表示每天8点到10点，每半小时执行</li>
<li>0 0 9-17 * * MON-FRI			表示每周一至周五，9点到17点的0分0秒执行</li>
<li>0 0 0 25 12 ?				表示每年圣诞节（12月25日）0时0分0秒执行</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
</feed>