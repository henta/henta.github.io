{"posts":[{"title":"比特币交易常见问题","content":"比特币交易常见问题比特币私钥原始私钥是32字节，也就是256位2进制数字，换算成16进制数字就是64位长度；私钥有16进制格式、WIF格式、WIF-compressed格式（WIF压缩格式）；WIF格式经过Base58check编码并以5作为前缀，WIF-compressed格式同样经过Base58Check编码并以K或L开头；私钥常常以WIF-compressed格式来展示，展示为以K或L开头的52位长度的数字和字母椭圆曲线算法（ECC）椭圆曲线算法是不可逆的，很容易向一个方向计算，但是不可以向相反方向倒退；比特币采用了SECP256K1算法（椭圆曲线算法的一种），将私钥生成公钥。SECP256K1是不可逆的，所以即使公钥公开暴露，也对私钥的安全性不会造成影响。Base64、Base58CheckBase64就是一种基于64个可打印字符来表示二进制数据的方法Base64字符集A~Za~z0~9+/Base58是用于比特币中的一种独特的编码方式，主要用于产生比特币钱包的地址相比Base64，Base58去除了一些容易混淆的相似字符：数字0和大写字母O，大写字母I和小写字母i，以及+和/公钥私钥和比特币地址之间的关系随机私钥生成公钥，公钥再生成比特币地址，且过程不可逆UTXO（unspenttransactionoutputs，未花费交易输出）用户比特币余额是用户钱包中可用的UTXO的总和。他们可能分布在数百个交易和区块中这些UTXO由用户所有的秘钥来控制花费行为。UTXO的面值为聪，是不可分割的价值单元，一个UTXO只能在一次交易中作为整体消耗每个比特币地址对应的UTXO，在交易过程中如同一张纸币一样（面额就是该比特币地址上的金额），不可以撕开使用，必须是作为一个整体来交易。未被交易的交易索引：检查inputs中的交易的txn是否在未被支付交易索引中即可。比特币交易验证一笔交易就是一个地址的比特币，转移到另一个地址。由于比特币的交易记录全部是公开的，哪个地址拥有多少比特币，都是可以查到的。因此，支付方是否有足够的比特币，完成这笔交易，是很容易验证的。问题在于怎么防止其他人，冒用你的名义申报交易。申报交易的时候，除了交易金额，转出比特币的一方还必须提供以下数据。上一笔交易的Hash（你从哪里得到的这些比特币）本次交易双方的地址支付方的公钥支付方的私钥生成的数字签名验证这笔交易是否属实，要经过三步第一步，找到上一笔交易，确认支付方比特币的来源第二步，算出支付方公钥的指纹，确认与支付方的地址一致（因为通过公钥可以算出地址），从而保证公钥属实第三步，用公钥去解开数字签名（数字签名只有拥有私钥才能生成），保证签名属实，私钥属实。经过上面三步，就可以认定这笔交易是真实的","link":"https://henta.github.io/post/bi-te-bi-jiao-yi-chang-jian-wen-ti/"},{"title":"比特币区块数据结构","content":"区块相关信息区块包括：区块头和区块体区块体记录了交易详情、交易计数器、区块大小区块头：每个区块的前80个字节（640bits），包含6部分信息Version版本号，4字节前一个区块的hash值，32字节本区块所有交易的默克尔根，32字节时间戳，4字节比特币是p2p网络，无中心服务器，每个节点的时间戳可能不同，因此有规定：新区快时间戳要大于前11个区块平均时间戳；不超过当前网络时间的两小时。所以后一个区块时间戳小于前一个也是有可能的。难度Bits，4字节随机数Nonce，4字节Nonce是全网矿工计算当前区块hash值得核心参数。Nonce的取值范围是0-2的32次方（42亿）","link":"https://henta.github.io/post/bi-te-bi-qu-kuai-shu-ju-jie-gou/"},{"title":"比特币私钥","content":"比特币私钥原始私钥是32字节，也就是256位2进制数字，换算成16进制数字就是64位长度；私钥有16进制格式、WIF格式、WIF-compressed格式（WIF压缩格式）；WIF格式经过Base58check编码并以5作为前缀，WIF-compressed格式同样经过Base58Check编码并以K或L开头；私钥常常以WIF-compressed格式来展示，展示为以K或L开头的52位长度的数字和字母","link":"https://henta.github.io/post/bi-te-bi-si-yao/"},{"title":"比特币交易的数据结构","content":"比特币交易的数据结构比特币区块的结构每一个数据区块记录了5个内容：魔法数、区块大小、区块头信息、交易数量、交易详情魔法数（Magicno.）占4字节正式网络中的魔法数：0xD9B4BEF9(实际区块中存储为小头位序，显示为F9BEB4D9)测试网络中魔法数:0×07091108(实际区块中存储为小头位序,显示为0B110907）私链网络中魔法数:0xDAB5BFA(实际区块中存储为小头位序,显示为FABFB5DA）区块大小(Blocksize)占4字节区块头(Blockheader)包含6个数据项,共占80字节区域版本号(Version),占4字节前一区块Hash(hashPrevBlock),占32字节Merkle根Hash,占32字节时间戳(Time),占4字节难度目标hash(bits),占4字节随机数(nonce),占4字节交易数量（Transactioncounter）占1~9字节交易详情（Transactions）包含6个数据项，字节大小取决了交易中输入和输出的数量比特币交易的数据结构交易数据格式的版本号(version)占4字节交易中输入的数量(tx_in_count)占1-9字节交易中输入的列表信息(tx_in)最少占41字节标准的P2PKH交易的输入包含8项信息上笔交易的hosh。占32字节该交易是上一笔交易的输出中的第几条。占4字节(索引下标从0开始)解锁脚本总长度。占106-108字节(私钥签名+压缩公钥的长度+2字节标记)私钥签名的长度。占1字节私钥签名的DER编码格式。占71~73字节压缩公钥的长度。占1字节压缩公钥。占33字节发送者定义的交易版本。就是JSON格式中的sequence。占4字节。常用于识别交易的一个输入结束。交易中输出的数量(tx_out_count)占1~9字节交易中输出的列表信息(tx_out)最少占8字节交易的输出包含3项信息交易金额。占8字节锁定脚本长度。至少占1字节锁定脚本内容。不定长度，根据脚本的复杂程度而可变长度锁定时间（lock_time）占4字节锁定时间表示在某个高度的区块诞生之前或某个时间点之前，该交易出于锁定状态而不能被收录进区块链中。只有在满足锁定条件后才能打包上链。lock_time==0,表示该交易可以立即被打包。lock_time&lt;500000000,lock_time表示区块高度，就是说这笔交易只能被打包进高度大于lock_time的区块lock_time&gt;=500000000,lock_time表示Unix时间戳，就是说这笔交易只能等待到当前时间大于lock_timeP2PKH交易的数据解析案例P2PKH交易的原始数据原始记录：交易记录的查询网址：https://blockchain.info/rawtx/ffc90e4b4ce15a97c1b560ad148da63cadaa898e366bf270ae307857a2606430?format=hexrawtx后面接交易id号format=hex表示以十六进制表示，不加就以json格式展示交易记录的16进制文件交易hash：ffc90e4b4ce15a97c1b560ad148da63cadaa898e366bf270ae307857a260643016进制文件如下：0100000002738522d9350e2edb9fd7b287e78d89f361acbc4ddb8463b1a83f757103ad7f3d010000006b483045022100eae02b94ca5a88168327e4cc4a15256745658e5c1022e51f134d07c7c192f8d102207a527ee05457420661d2f8e583a69847fb86586c2206d57df121c7842117b672012103b66167e405a3b5483750cb21a14bff75d2080e1785dcfc21801f322382fb5ed5ffffffffbe5535e467861a3061f8a6ca30a6375ad14389425c77515092698d7fdd33544e010000006a4730440220689198269768623e755a5d9e617a70ffd045d4c9f99d859a8c609bff6cea0349022059d9da5c5737e407e45b5bc836161bff77eb5fae273899f0bc43bc98616e6683012102387d8b1a297e71327dc3f01137e8edcf66a2a7531935c2baca498726482529ceffffffff027cc5c800000000001976a9149bf3e6b720106f7a802fa5a84a461fa1c660163888ac80c3c9010000000017a914c4f45400fc2c1eeff8ae8fb709f9b9ce1eef952b8700000000计算机存储的16进制数据是小头位序排列格式，即低位在前，高位在后。区块链浏览器中16进制数值显示是大头位序排列形式，因为人们的读写习惯，数值从左至右读，左侧是大数，右侧是小数。所以在解析16进制文件时，需要将数据转成大头位序排列格式后再运算。交易数据结构解析版本号01000000//转成大头位序排列为：00000001，所以版本号为1交易中的输入数量02//输入数量为2个交易中输入的列表信息第一笔交易输入上一笔交易的hash，占32字节738522d9350e2edb9fd7b287e78d89f361acbc4ddb8463b1a83f757103ad7f3dcoinbase交易输出结构","link":"https://henta.github.io/post/bi-te-bi-jiao-yi-de-shu-ju-jie-gou/"},{"title":"比特币交易和签名","content":"比特币交易和签名概述交易是比特币系统中最重要的部分每一笔交易的每一项输出严格意义上并不是指向一个地址，而是指向一个脚本脚本类似一套规则，他约束着收币方必须满足一定条件才能花掉收币地址上锁定的资产。交易的本质是包含了一组输入和输出的数据结构，也就是转账记录。输入和输出可以简单理解为：发币地址是输入，收币地址是输出。输入中包含解锁脚本（unlockingscript）解锁脚本是锁定脚本对应的脚本。锁定脚本相当于出了一个加密难题，而解锁脚本相当于是解开锁定脚本的一个题解。当解锁脚本满足锁定脚本要求的条件，就能花掉锁定脚本上对应的资产。用scripSig表示。简单的交易类型中的解锁脚本就是支付方用自己的私钥所做的签名。输出中包含锁定脚本（lockingscript）交易输出中包含了交易的转账金额以及收币方的比特币地址。而锁定脚本就是在交易输出上附加了一个条件。由于锁定脚本往往含有一个公钥或者比特币地址，所以曾经就被称为公钥脚本。在代码中常用scriptPubKey表示。其实这种脚本技术存在更为广泛的可能性，更确切的叫法应该是锁定脚本在简单的交易类型中，锁定脚本中附加的条件就是收币方的公钥，将收币方的公钥与转账资产锁定在一起，意思就是只有拥有这个公钥的人才能解锁并有权花费其中的资产。要花费这笔被锁定的资产，就需要证明自己是锁定脚本里的那个公钥的所有者，最有利的证据就是用配套的私钥来证明，但是出于安全考虑，私钥是不能公开到网络中的，于是采用私钥生成的签名来代替私钥。如果签名与锁定资产的公钥相匹配，那么就有权花费这笔被锁定的资产。签名是通过secp256K1椭圆曲线加密算法实现的，知道签名也没有办法逆推出私钥，所以这是安全的签名方法。交易链前一笔交易的输出是一个加密难题，需要用这笔钱的时候，就需要在新交易中的输入中加入解锁脚本解开加密难题签名序列化（DER）￼什么是DER？DER（DistinguishEncodingRules，可辨别编码规则）椭圆曲线加密算法对数据签名可以产生由两个值组成的签名Sig，通常称为R和S计算出R和S后，需要使用DER国际标准编码方案，将其序列化为16进制字节码格式椭圆曲线的数字签名其实是R和S值的序列化字节码。签名格式分析如下图第二部分序列的长度值决定了数字签名的总长度序列长度为44，签名总长度为71字节（142位16进制数字）序列长度为45，签名总长度为72字节（144位16进制数字）序列长度为46，签名总长度为73字节（146位16进制数字）Secp256K1实现交易签名及签名验证比特币交易生命周期交易流程就是交易的生命周期。区块链的交易并不是通常意义上的一手交钱一手交货的交易，而是转账。比特币的交易可以包含多个输入和输出。可以理解成一笔交易可以有多个银行卡的资金来源，并且一次交易可以转账给多个人。比特币交易的生命周期包括：创建交易、广播交易、打包交易、交易上链、交易回退。创建交易：支付方A的客户端钱包优先搜索A用户的UTXO列表信息，找寻A是否有足够的资金进行支付。如果A有UTXO，那么A需要用自己的私钥，对每一个UTXO做签名，同时附加上每一个UTXO对应的公钥，以证明自己对该笔资金具有使用权。这些信息附加在A的支付方地址上，这就是解锁脚本。A在给收币方B转账过程中，会在转账金额末尾附加一个加密难题，从而将该笔转账资金进行锁定，只有满足条件的人才有权使用该笔资金。这就是锁定脚本。锁定脚本中一般锁定的是收币方的公钥或者公钥hash。比特币交易中的每个输出可以设置多个加密难题，那么该输出下次被使用时就需要多个签名来解密。交易一旦被创建也就意味着交易的生命周期开始了广播交易：比特币交易被创建后，会广播到比特币网络中，网络中邻近的全节点收到交易信息，先放到本地的内存，然后对交易进行验证。比如这笔交易的input中引用的交易是否属于UTXO。若验证不成功，则交易会被认为是invalidTransaction--无效交易。若验证成功后这些交易会被认为是UnconfirmTransation--未确认交易，”未确认交易“会被放置在节点的有效交易池中等待被打包。比特币是一种全网记账的系统,因此每笔交易发生后,会在全网广播。每一个收到交易的比持币节点都会首先验证交易,有效的交易将被传递到临近的节点,这确保了只有有效的交易才会在网络中传播,而无效的交易将会在第一个节点处就被废弃。周边的全节点接到这笔交易后,也一样先放入内存进行验证,验证通过再放入有效交易池中等待被打包。钱包收到比特币，其实就是钱包检测到了可用的UTXO。通过钱包控制的秘钥，可以把这些UTXO花出去。因此，用户的比特币”余额“是指用户钱包中可用的UTXO总和。全节点客户端中,chainstate目录下的*.ldb文件中存放的就是UTXO记录。一个UTXO可以是1”聪“的任意整数倍。尽管UTXO可以是任意值，但一旦被创造出来，即不可分割。这是UTXO值得被强调的一个重要特性：一个UTXO只能在一次交易中作为一个整体被消耗。但是比特币系统也可以找零。打包交易挖矿节点每次开始挖矿就按一定的优先级次序从交易池中抽取近千笔未确认交易，打包进区块，打包时会将上一个区块的Hash值也加入包中。然后开始执行挖矿。交易上链：争夺记账权:挖矿节点利用工作量证明来争夺记账权。当挖矿成功,该节点生成新区块后,整个过程并没有结束,该节点接下来会发起一次全网记账。全网记账:挖矿成功的节点,将新区块的数据记录在自己的硬盘上,并同时将数据广播至全网,周边的节点接收到之后再传递给其它周边的节点,直到全网都收到这个信息。接收到信息的节点对新区块数据进行核对。验证通过后,各个节点将该区块数据追加到比特币主链的最后端,其实就是记录到自己节点的硬盘中,这样来确保本地的区块链数据更新为最新的数据。更新交易池:挖矿节点在接收并验证新区块数据后,会检查自己内存池中的全部交易,移除已经在新区块中出现过的交易记录,确保任何留在内存池中的交易都是未确认的。而那些被移除的交易记录其实就获得了一次交易“确认”。更新UTXO索引:每一次交易都代表这UTXO集合的变化,交易结束,节点会更新UTXO索引。把包含在区块内且被添加到区块链上的交易称为“确认”交易,交易经过6次“确认”之后,就认为交易是安全不可更改的。此时交易接收方就能花费他在交易中得到的比特币。至此交易就永久被保存在了区块链上而不能被篡改和删除,也就意味着交易的生命周期结束了。交易回退：如果不巧出现临时分叉，则等到最长连诞生后，分叉的区块会断链并将其中记录的交易回退到交易池中，等待重新被打包上链。","link":"https://henta.github.io/post/bi-te-bi-jiao-yi-he-qian-ming/"},{"title":"比特币挖矿原理","content":"挖矿原理挖矿的过程就是不断改变Nonce计算hash的过程以551675区块为例，模拟挖矿过程：将区块头中的六个参数以16进制的小端结尾方式连接在一起小端结尾就是将字节颠倒顺序，在16进制表示中，2个16进制数值代表了1个字节，所以就两个两个的颠倒版本号：0x20000000version=&quot;02000000&quot;上一块的hash：000000000000000000080f18263448e7d679c4ef5f2781a1272146556b824a54pre_version=&quot;544a826b55462127a181275fefc479d6e7483426180f08000000000000000000&quot;merkle_root:2c16a0662dfbeec9d13d8d9bc54d995e47492e8baf8e6344e5617b1e70b4baf8merkle_root=&quot;f8bab4701e7b61e544638eaf8b2e49475e994dc59b8d3dd1c9eefb2d66a0162c&quot;时间戳：1543275021（2018-11-2707:30:21，转16进制为5bfc820d）time_stamp=&quot;0d82fc5b&quot;难度目标Bits：38864849516进制:172a4e2fbits=&quot;2f4e2a17&quot;Nonce:303995743616进制：b53211bcnonce=&quot;bc1132b5&quot;head_hex=version+pre_hash+merkle_root+time_stamp+bits+nonce=02000000544a826b55462127a181275fefc479d6e7483426180f08000000000000000000f8bab4701e7b61e544638eaf8b2e49475e994dc59b8d3dd1c9eefb2d66a0162c0d82fc5b2f4e2a17bc1132b5再计算两次hash256并且转码转回大端比对目标大小，需要实际计算的hash值&lt;目标hash大小才算验证成功","link":"https://henta.github.io/post/bi-te-bi-wa-kuang-yuan-li/"},{"title":"spring定时任务","content":"spring定时任务Schedule我们使用@Scheduled来创建定时任务，并通过在启动类上加上@EnableScheduling注解开启定时任务。这个注解用来标注一个定时任务方法。通过看@Scheduled源码可以看出它支持多种参数：1.cron：cron表达式，指定任务在特定时间执行；2.fixedDelay：表示上一次任务执行完成后多久再次执行，参数类型为long，单位ms；3.fixedDelayString：与fixedDelay含义一样，只是参数类型变为String；4.fixedRate：表示按一定的频率执行任务，参数类型为long，单位ms；5.fixedRateString:与fixedRate的含义一样，只是将参数类型变为String；6.initialDelay：表示延迟多久再第一次执行任务，参数类型为long，单位ms；7.initialDelayString：与initialDelay的含义一样，只是将参数类型变为String；8.zone：时区，默认为当前时区，一般没有用到。定时任务默认是单线程启动的，想要多线程执行定时任务，可以做如下配置@Configuration//所有的定时任务都放在一个线程池中，定时任务启动时使用不同都线程。publicclassScheduleConfigimplementsSchedulingConfigurer{@OverridepublicvoidconfigureTasks(ScheduledTaskRegistrartaskRegistrar){//设定一个长度10的定时任务线程池taskRegistrar.setScheduler(Executors.newScheduledThreadPool(10));}}cron详解Cron表达式是一个字符串，是由空格隔开的6或7个域组成，每一个域对应一个含义（秒分时每月第几天月星期年）其中年是可选字段。但是，spring的schedule值支持6个域的表达式，也就是不能设定年，如果超过六个则会报错。各域支持的类型：秒：可出现&quot;,-*/&quot;四个字符，有效范围为0-59的整数分：可出现&quot;,-*/&quot;四个字符，有效范围为0-59的整数时：可出现&quot;,-*/&quot;四个字符，有效范围为0-23的整数每月第几天：可出现&quot;,-*/?LWC&quot;八个字符，有效范围为0-31的整数月：可出现&quot;,-*/&quot;四个字符，有效范围为1-12的整数或JAN-DEc星期：可出现&quot;,-*/?LC#&quot;四个字符，有效范围为1-7的整数或SUN-SAT两个范围。1表示星期天，2表示星期一，依次类推特殊字符含义*:表示匹配该域的任意值，比如在秒*,就表示每秒都会触发事件；?:只能用在每月第几天和星期两个域。表示不指定值，当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“?”；-:表示范围，例如在分域使用5-20，表示从5分到20分钟每分钟触发一次/:表示起始时间开始触发，然后每隔固定时间触发一次，例如在分域使用5/20,则意味着5分，25分，45分，分别触发一次.,:表示列出枚举值。例如：在分域使用5,20，则意味着在5和20分时触发一次L:表示最后，只能出现在星期和每月第几天域，如果在星期域使用1L,意味着在最后的一个星期日触发W:表示有效工作日(周一到周五),只能出现在每月第几日域，系统将在离指定日期的最近的有效工作日触发事件。注意一点，W的最近寻找不会跨过月份LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五#:用于确定每个月第几个星期几，只能出现在每月第几天域。例如在1#3，表示某月的第三个星期日例子00****表示每小时0分0秒执行一次*/10*****表示每10秒执行一次008-10***表示每天8，9，10点执行00/308-10***表示每天8点到10点，每半小时执行009-17**MON-FRI表示每周一至周五，9点到17点的0分0秒执行0002512?表示每年圣诞节（12月25日）0时0分0秒执行","link":"https://henta.github.io/post/spring-ding-shi-ren-wu/"},{"title":"同类调用导致的spring事务失效","content":"本人在工作过程中发现项目有一块的事务不生效，遂进行了以下的探究。本文通过两个案例深入讲解事务失效的原因以及提供一些有效的解决方法案例1publicinterfaceAService{publicvoida();publicvoidb();}@ServicepublicclassAServiceImplimplementsAService{publicvoida(){this.b();}@Transactional(rollbackFor={Exception.class})publicvoidb(){insert();update();}}同类中一个没有@Transaction的方法调用有@Transaction的方法时，事务将会失效原因根本原因在于spring对于事务的管理方式：spring使用aop去管理事务对于上述AServiceImpl，在运行时，spring会自动生成其代理类如下：publicclassAServiceImplProxyimplementsAService{publicvoida(){//反射调用目标类的a方法AServiceImpl.a();}publicvoidb(){//启动事务的代码begin;try{//反射调用目标类的b方法AServiceImpl.b();}catch{rollback;}//事务提交的代码commit;}}在调用getBean(&quot;AServiceImpl&quot;).a()时，实际上执行的是AServiceImplProxy.a(),而AServiceImplProxy.a()调用的是源类中的a()方法，源类中a()再去调用b(),显而易见，并没有用到代理类中的AServiceImplProxy.b(),自然不会有事务管理。案例2a()有@Transactionb()有@Transaction或无@Transaction@ServicepublicclassAServiceImplimplementsAService{@Transactional(rollbackFor={Exception.class})publicvoida(){this.b();}@Transactional(rollbackFor={Exception.class})publicvoidb(){insert();update();}}其实原理流程和案例1的差不多，上层类调用a()时，只会开启对于a()的事务，b的事务并没有起作用，但是因为spring的机制，会将b()自动加入到a()的事务中，所以a()方法也将b()管理了起来。对于案例1，a()连事务都没有调用，自然也不会自动将b()管理到a()注意点：虽然a()的事务会将b()管理起来，但是其实在b()上的注解是失效的，也就是说如果你想用不同的事务传播机制(如这种PROPAGATION_SUPPORTS)，机制将会失效,rollbackFor也只能沿用a()定义的解决方案显式的事务编程(不推荐，丧失了aop的方便性)显式的调用代理类中的b()将暴露Proxy类设置为true@EnableAspectJAutoProxy(exposeProxy=true)然后显式调用代理类的b()@Transactional(rollbackFor={Exception.class})publicvoida(){((AService)AopContext.currentProxy()).b();//即调用AOP代理对象的b方法即可执行事务切面进行事务增强}这种做法很方便，但是不能保证以后新添加的代码不出现相同的问题3.进行接口下沉，避免出现案例1的情况-将一些操作数据库的通用方法放到另外的service里，这样不会出现同类调用transaction的尴尬情况-这种做法比较优雅，也能完全避免出现事务失效的情况总结不仅仅是@Transaction注解，几乎所有与AOP有关的注解都存在上述的问题，工作中需要格外注意现在代码大部分情况都是案例2中的情况，小部分是案例1中的情况，以后写代码的时候如果需要对注解有格外的定义，要记住案例2的情况中，注解将会失效其实还是要在写代码的时候有规范意识，不要所有东西都写在一起，专业的类干专业的事查看mybatis和事务日志：logging.level.com.okcoin.vault.service.dao.mapper=debuglogging.level.org.springframework.jdbc.datasource.DataSourceTransactionManager=debug","link":"https://henta.github.io/post/tong-lei-diao-yong-dao-zhi-de-spring-shi-wu-shi-xiao/"},{"title":"闪电网络原理","content":"闪电网络基本概念和步骤闪电网络就是将btc的小额交易放到链下去进行，等到双方交易结束后再将最后的账单上链，中间的交易过程无需上链，可以做到秒到账且低手续费。openChannel（建立交易通道）：A和B协商好双方投入的资金，然后在比特币链上创建一个2/2的多重签名交易，需要花费output需要双方共同签名开始交易：建立好通道后，双方可以通过这个链下的通道进行交易，在第一步双方投入的金额内，交易可以进行无线多次，这些交易都不上链，双方只会&quot;记账&quot;closeChannel（关闭交易通道）：双方交易结束后需要将最终的账单统合，并且共同去花费第1步的output，进行最终的上链过程问题:这种想法虽然好，但是怎么保证双方诚信？如果最后A舍弃了自己剩余的0.3btc（可能是故意或者私钥丢了），就是不配合B去花费2/2的output，这样B就损失了0.7个btc。当初说好的给彼此之间一点信任呢？原理首先，上述问题的根本在于output是2/2的脚本，需要两个人共同花费，对于陌生的交易双方来说，风险太大，所以闪电网络需要设计出任意一方都可以将output正确花费的方法A和B在openChannel后，都为那个2/2的output构建一笔新交易图中[]表示现在还不具备的东西，R表示随机数，Ra表示A的随机数，Rb表示b的随机数，RevocableSequenceMaturityContract(RSMC)可撤销序列成熟合约A和B将各自签名好的交易互相交换，现在可以观察一下，A和B都可以将对方给的交易上链了，但是如果对方不同意的话，RSMC脚本只能通过等待1000个区块去花费了，这就是强制上链的惩罚，而对方同意的话，可以直接通过对方的签名去花费这个RSMC，也就是可以即时花费RSMC的原理其实就是多签脚本，时间锁条件是用比特币自带的参数timelock实现，需要R解锁的条件是利用了Hash不可逆推实现，B先会给AR的hash让A去构建这个交易脚本，之后拥有R解锁这个hash合约这样一来任一方都可以closeChannel，只不过分为和平关闭和强制关闭这就是为什么双方都同意建立交易通道的原因：只要我愿意，我们的交易一定会上链现在双方在交易通道里继续交易记账比如，A支付给了B0.1btc，这时候双方会重新签一个未完成交易给对方：通道内转账更新账单其实就是双方更新签名交易问题来了，现在A手里有两个时期的未上链交易，A一看，我肯定愿意把最开始双方都得0.5btc的交易签名上链啊，这时候B肯定不同意，但是A却强制上链了，A只需要等待1000个块确认就能使用0.5btc了，白赚了0.1btc于是闪电网络规定，废弃掉上一个账单的时候，你必须把自己的随机数R交给对方，那么再来看看这个规定后的场景A同样想要把0.5btc的那笔交易上链，假设他也这么做了，A需要等待1000个确认才能花费RSMC中的0.5btc，而这个时候B发现A干坏事了，由于A之前已经把Ra给了B，B可以直接通过Bsig+Ra的方式先一步使用RSMC脚本花费掉这0.5btc，这样一来B其实就拥有了1btc。这也是闪电网络对不诚信节点的惩罚上述的情况都是发生在A直接能连到B的情况下，但是闪电网络是一个巨大的网络，A并不能保证每次都能直接连到B，这时候C节点刚好连着B，于是A就将C节点当成中间人去和A交易比如：A要转0.1btc给DDave准备一个随机数R，并计算其哈希H，将H给了AliceAlice和Bob建立通道的时候约定，如果3天内Bob能给出R，那Alice给Bob0.102btc，超过3天，拿回这些币Bob和Carol建立通道的时候约定，如果2天内Carol能给出R，Bob就给Carol0.101btcCarol和Dave建立通道的时候约定，如果1天内Dave能给出R，Carol就给Dave0.1btc最终，Dave把自己拥有的R给了Carol拿到了0.1btc，Carol用这个R换到了Bob的0.101btc，而Bob用R换到了Alice的0.102btc皆大欢喜。上述的流程就是闪电网络中的HTLC（HashedTimelockContract）哈希时间锁定合约来实现的，原理和上面差不多，比特币脚本是支持生成这种规则的output的总结现在的闪电网络都是需要收款方先提供一个二维码或者code给付款者的，这个code包含的信息其实就有H、金额等信息技术方面逻辑都很清晰成熟，现在闪电网络的运行也比较平稳，还没有听说有丢币事件。","link":"https://henta.github.io/post/shan-dian-wang-luo/"},{"title":"Hello Gridea","content":"👏欢迎使用Gridea！✍️Gridea一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意......GithubGridea主页示例网站特性👇📝你可以使用最酷的Markdown语法，进行快速创作🌉你可以给文章配上精美的封面图和在文章任意位置插入图片🏷️你可以对文章进行标签分组📋你可以自定义菜单，甚至可以创建外部链接菜单💻你可以在Windows，MacOS或Linux设备上使用此客户端🌎你可以使用𝖦𝗂𝗍𝗁𝗎𝖻𝖯𝖺𝗀𝖾𝗌或CodingPages向世界展示，未来将支持更多平台💬你可以进行简单的配置，接入Gitalk或DisqusJS评论系统🇬🇧你可以使用中文简体或英语🌁你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力🖥你可以自定义源文件夹，利用OneDrive、百度网盘、iCloud、Dropbox等进行多设备同步🌱当然Gridea还很年轻，有很多不足，但请相信，它会不停向前🏃未来，它一定会成为你离不开的伙伴尽情发挥你的才华吧！😘Enjoy~","link":"https://henta.github.io/post/hello-gridea/"}]}